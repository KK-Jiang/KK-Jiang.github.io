<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>KK&#39;s Note</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://jkknotes.com/"/>
  <updated>2019-11-15T12:29:35.309Z</updated>
  <id>https://jkknotes.com/</id>
  
  <author>
    <name>KK.J</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>awk命令详解</title>
    <link href="https://jkknotes.com/awk%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/"/>
    <id>https://jkknotes.com/awk命令详解/</id>
    <published>2019-11-13T13:42:36.000Z</published>
    <updated>2019-11-15T12:29:35.309Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>awk 其名称的由来很简单，就是由其三个创始人Alfred Aho 、Peter Weinberger 和 Brian Kernighan 姓氏的首个字母组成。很多人都说它是一个效率神器，以前也多多少少用过它一些简单的用法。后来python一上手，pandas一用上，反而忘了它。正所谓技多不压身，这么高大上的程序语言（速度快，常用命令简单， 效率高），一定要学会它。所以这篇文章特将awk的基本语法，常用的命令以及相对应的命令记录下来，以备需要时直接复制使用。<a id="more"></a></p><p>awk语言的最基本功能是在文件或者字符串中基于指定规则浏览和抽取信息，awk抽取信息后，才能进行其他文本操作。awk脚本通常用来格式化文本文件中的信息。awk是以文件的每一行为处理单位的，即其对所接收文件或者其他文本内容的一行执行相应的命令，来处理文本。</p><h1 id="1-基本格式"><a href="#1-基本格式" class="headerlink" title="1.基本格式"></a>1.基本格式</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">'&#123;命令&#125;'</span> file1, file2, ...</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">其他命令的输出 ｜ awk <span class="string">'&#123;命令&#125;'</span></span><br></pre></td></tr></table></figure><p>举个例子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">'&#123;print $1&#125;'</span> demo.txt</span><br></pre></td></tr></table></figure><p>awk的命令一般写在花括号里，但是花括号并不是必须的，某些情况下它可以省略，或者压根不需要。下面看具体讲解和实例。</p><h1 id="2-基本用法"><a href="#2-基本用法" class="headerlink" title="2.基本用法"></a>2.基本用法</h1><h2 id="2-1-awk内置变量"><a href="#2-1-awk内置变量" class="headerlink" title="2.1 awk内置变量"></a>2.1 awk内置变量</h2><p>前面说了，awk一般以行为单位进行处理，下表中的<strong>记录行</strong>即表示文件的一行，这是默认情况下以换行符作为判断为一行的标志，当然也可以手动修改以其他字符作为换行标志。下表中的字段可以理解为使用分隔符分隔记录行后的每一个元素。<br>以下是awk内置变量及其含义：</p><table><thead><tr><th>变量名</th><th>含义</th></tr></thead><tbody><tr><td>$0</td><td>当前记录行</td></tr><tr><td>$1 ~ $n</td><td>当对当前记录行进行分隔时，表示分隔后第几个字段</td></tr><tr><td>FS</td><td>字段分隔符，默认是空格</td></tr><tr><td>RS</td><td>记录行分隔符，默认为换行符</td></tr><tr><td>NF</td><td>对记录行进行分隔后，字段的个数</td></tr><tr><td>NR</td><td>已经读出对记录数，从1开始，多个文件时继续累加计数</td></tr><tr><td>FNR</td><td>已经读出对记录数，从1开始，多个文件时每个文件单独计数</td></tr><tr><td>ORS</td><td>输出时的记录行分隔符， 默认是换行符</td></tr><tr><td>OFS</td><td>输出时的字段分隔符， 默认是空格</td></tr></tbody></table><h2 id="2-2-n、-F、FS、RS"><a href="#2-2-n、-F、FS、RS" class="headerlink" title="2.2 $n、-F、FS、RS"></a>2.2 $n、-F、FS、RS</h2><p>首先看 <strong>$0 ~ $n 和 -F</strong> 的例子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; cat awk_test.txt</span><br><span class="line">a,b,c,d</span><br><span class="line">e,f,g,h</span><br><span class="line"></span><br><span class="line">&gt;&gt; awk <span class="string">'&#123;print $0&#125;'</span> awk_test.txt <span class="comment"># 实例1</span></span><br><span class="line">a,b,c,d</span><br><span class="line">e,f,g,h</span><br><span class="line">&gt;&gt; awk -F <span class="string">','</span> <span class="string">'&#123;print $1,$2,$3,$4&#125;'</span> awk_test.txt <span class="comment"># 实例2</span></span><br><span class="line">a b c d</span><br><span class="line">e f g h</span><br></pre></td></tr></table></figure><p>这里的 ‘-F’ 命令用于定义按什么进行分隔，功能同python里的split。‘$0’ 表示整个记录行（实例1），‘$1,$2,$3,$4’表示分隔后的每个元素。</p><p>再继续来看<strong>FS和RS</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; awk -F <span class="string">','</span> <span class="string">'&#123;print $1 FS $2,$3,$4&#125;'</span> awk_test.txt <span class="comment"># 实例3</span></span><br><span class="line">a,b c d</span><br><span class="line">e,f g h</span><br><span class="line"></span><br><span class="line">&gt;&gt; awk -F <span class="string">','</span> <span class="string">'&#123;print $1 RS $2,$3,$4&#125;'</span> awk_test.txt <span class="comment"># 实例4</span></span><br><span class="line">a</span><br><span class="line">b c d</span><br><span class="line">e</span><br><span class="line">f g h</span><br></pre></td></tr></table></figure><p>实例3中，FS的值已经由‘-F’命令赋值成‘，’了；实例4中，RS默认为换行符，所以输出结果进行了换行。</p><p>如果想用多个分隔符分隔记录行，只需要将多个分隔符放在 [分隔符1 隔符2 ..] 中，如果想用一个或者多个相同分隔符进行分隔，可以写成  [分隔符1 隔符2 ..]+ 。继续看例子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; <span class="built_in">echo</span> <span class="string">'I am Poe,my qq is 0000001'</span> | awk -F <span class="string">'[" ",]'</span> <span class="string">'&#123;print $3 " " $7&#125;'</span></span><br><span class="line">Poe 0000001</span><br><span class="line"></span><br><span class="line">&gt;&gt; <span class="built_in">echo</span> <span class="string">'I am Poe,,my qq is 0000001'</span> | awk -F <span class="string">'[" ",]+'</span> <span class="string">'&#123;print $3 " " $7&#125;'</span></span><br><span class="line">Poe 0000001</span><br></pre></td></tr></table></figure><p>不解释了，已经很清楚了。</p><h2 id="2-3-NF、NR、FNR"><a href="#2-3-NF、NR、FNR" class="headerlink" title="2.3 NF、NR、FNR"></a>2.3 NF、NR、FNR</h2><p>先看 <strong>NF和NR</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; cat awk_test.txt</span><br><span class="line">a,b,c,d</span><br><span class="line">e,f,g,h</span><br><span class="line"></span><br><span class="line">&gt;&gt; awk -F <span class="string">','</span> <span class="string">'&#123;print NR") "$0"\t size is "NF&#125;'</span> awk_test.txt</span><br><span class="line">1) a,b,c,dsize is 4</span><br><span class="line">2) e,f,g,hsize is 4</span><br></pre></td></tr></table></figure><p>可以看到，结果中有行号，即为NR， 输出结果中的 4 即为字段数。<br>再看以下<strong>FNR及其和NR的区别</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; cat file.txt</span><br><span class="line">aaaaaa</span><br><span class="line">bbbbbb</span><br><span class="line"></span><br><span class="line">&gt;&gt; awk -F <span class="string">','</span> <span class="string">'&#123;print NR") "$0&#125;'</span> awk_test.txt file.txt</span><br><span class="line">1) a,b,c,d</span><br><span class="line">2) e,f,g,h</span><br><span class="line">3) aaaaaa</span><br><span class="line">4) bbbbbb</span><br><span class="line"></span><br><span class="line">&gt;&gt; awk -F <span class="string">','</span> <span class="string">'&#123;print FNR") "$0&#125;'</span> awk_test.txt file.txt</span><br><span class="line">1) a,b,c,d</span><br><span class="line">2) e,f,g,h</span><br><span class="line">1) aaaaaa</span><br><span class="line">2) bbbbbb</span><br><span class="line"></span><br><span class="line">&gt;&gt; awk -F <span class="string">','</span> <span class="string">'&#123;if (NR==FNR) print $0&#125;'</span> awk_test.txt file.txt</span><br><span class="line">a,b,c,d</span><br><span class="line">e,f,g,h</span><br></pre></td></tr></table></figure><p>很清楚了吧</p><h2 id="2-4-OFS、ORS"><a href="#2-4-OFS、ORS" class="headerlink" title="2.4 OFS、ORS"></a>2.4 OFS、ORS</h2><p>同样的看个例子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; <span class="built_in">echo</span> <span class="string">'1 2 3'</span> | awk <span class="string">'BEGIN &#123;OFS="|"&#125; &#123;print $1,$2,$3&#125;'</span> <span class="comment"># 实例5</span></span><br><span class="line">1|2|3</span><br><span class="line"></span><br><span class="line">&gt;&gt; cat awk_test.txt | awk -F <span class="string">','</span> <span class="string">'&#123;print $1$2&#125;'</span></span><br><span class="line">ab</span><br><span class="line">ef</span><br><span class="line"></span><br><span class="line">&gt;&gt; cat awk_test.txt | awk -F <span class="string">','</span> <span class="string">'BEGIN &#123;ORS="---"&#125; &#123;print $1$2&#125;'</span> <span class="comment"># 实例6</span></span><br><span class="line">ab---ef---</span><br></pre></td></tr></table></figure><p>这里出现了一个新的语法，BEGIN，其作用是定义在命令执行之前需要执行的操作，在实例5中，在命令执行之前将输出时的字段分隔符赋值成了‘｜’。实例6同理。</p><h2 id="2-5-BEGIN、END-命令、运算符"><a href="#2-5-BEGIN、END-命令、运算符" class="headerlink" title="2.5 BEGIN、END 命令、运算符"></a>2.5 BEGIN、END 命令、运算符</h2><h3 id="2-5-1-BEGIN-和-END-命令"><a href="#2-5-1-BEGIN-和-END-命令" class="headerlink" title="2.5.1 BEGIN 和 END 命令"></a>2.5.1 BEGIN 和 END 命令</h3><p>在许多编程情况中，需要在 awk 开始处理输入文件中的文本之前执行初始化操作。这个时候 可以定义一个 BEGIN 块。</p><p>因为 awk 在开始处理输入文件之前会执行 BEGIN 块，因此它是初始化 各种变量（包括内置变量，全局变量）的极佳位置。<br>相对应的，awk 还提供了另一个特殊块，叫作 END 块。 awk 在处理了输入文件中的所有行之后执行这个块。通常， END 块用于执行最终计算或打印应该出现在输出流结尾的摘要信息。</p><p>下面这个例子的作用是统计某个文件夹下的文件占用的字节数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; ll |awk <span class="string">'BEGIN &#123;size=0&#125; &#123;size=size+$5&#125; END&#123;print "[end]size is ",size/2014/1024, "M"&#125;'</span></span><br><span class="line">[end]size is 3.3 M</span><br></pre></td></tr></table></figure><p>这样一个简单的例子信息量还是挺丰富的。首先可以看到所有的命令都在 ‘ ’ 里，BEGIN and END 以及记录行正常的操作部分，都有单独的代码块，用 {} 区分。另外我们可以看到，awk支持自定义变量，还可以进行各种运算。实际上awk也是一个轻量级的编程语言。这里代码“BEGIN {size=0}”可以省略，awk默认size=0.</p><h3 id="2-5-2-awk运算符"><a href="#2-5-2-awk运算符" class="headerlink" title="2.5.2 awk运算符"></a>2.5.2 awk运算符</h3><p>既然awk也算是一个编程语言，那自然支持各种运算。如下表所示：</p><table><thead><tr><th>运算符</th><th>解释</th></tr></thead><tbody><tr><td>=、+、-、+=、-=、<em>=、/=、%=、*</em>=、++、–等</td><td>赋值及数学运算</td></tr><tr><td>||、&amp;&amp;</td><td>逻辑或、逻辑与</td></tr><tr><td>&lt;、&lt;=、&gt;、&gt;=、!=、==</td><td>关系运算符</td></tr><tr><td>?:</td><td>三目运算符</td></tr><tr><td>in</td><td>数组中是否存在某键值</td></tr></tbody></table><p>随便举个例子，其余的看看就好：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; awk <span class="string">'BEGIN&#123;a="b";print a=="b"?"ok":"err"&#125;'</span></span><br><span class="line">ok</span><br><span class="line">&gt;&gt; awk <span class="string">'BEGIN&#123;a="b";print a=="c"?"ok":"err"&#125;'</span></span><br><span class="line">err</span><br></pre></td></tr></table></figure><h3 id="2-5-3-awk-数组和循环"><a href="#2-5-3-awk-数组和循环" class="headerlink" title="2.5.3 awk 数组和循环"></a>2.5.3 awk 数组和循环</h3><p>awk的循环包含while、do…while、for循环。这里不介绍了。具体可看链接：<a href="https://www.cnblogs.com/ginvip/p/6352157.html" target="_blank" rel="noopener">https://www.cnblogs.com/ginvip/p/6352157.html</a></p><p>说说数组。awk的数组像极了python里的dict。有数组的地方，常常也有循环，当然这不是绝对的。<br>这次的实例使用一个真实的log文件，先看看log前2行长什么样（涉及到实际业务，做了一些处理）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; cat awk_log.log | head -n 2</span><br><span class="line">2019-10-22 18:11:42,726 feature_name_unify.py[line:99] ERROR: d_type, origin_name, sample_type, exam_name: exam,awk,linux,awk命令简介</span><br><span class="line">2019-10-22 18:11:42,727 feature_name_unify.py[line:99] ERROR: d_type, origin_name, sample_type, exam_name: exam,grep,linux,awk命令简介1</span><br></pre></td></tr></table></figure><p>整个log文件有0.18亿行。现在想统计按逗号分隔后倒数第三个位置会出现哪几种字符，及其频数。为了简单起见，用前20行做统计：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; cat awk_log.log | head -n 20 | awk -F <span class="string">','</span> <span class="string">'&#123;a[$6]++&#125; END &#123;for (x in a) print x "\t" a[x]&#125;'</span></span><br><span class="line">awk7</span><br><span class="line">grep6</span><br><span class="line">seed3</span><br><span class="line">ls3</span><br><span class="line"><span class="built_in">pwd</span>1</span><br></pre></td></tr></table></figure><p>这个例子先将这个log文件的前20行输出，以便awk处理；在使用awk处理时，先使用逗号进行分隔；后面对记录行的每一个操作都写在单引号 ‘’ 里，每一个{}是一个代码块；对于代码块 {a[$6]++} ，a表示一个数组，这个数组可以理解为python里的dict，$6是其索引；初始时，a[$6] = 0，后面随着处理的记录行增加，每来一个相同的索引，就加1；END {for (x in a) print x “\t” a[x]}在处理完所有记录行后执行，此时用一个循环，打印出数组a的索引及其值。就如同打印出python字典里的key和value。</p><p>再来一个更复杂的例子，统计一个公司每个部门的人数及具体姓名：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; cat company.csv | head -n 3</span><br><span class="line">部门,姓名,性别</span><br><span class="line">技术研发部,张三,男</span><br><span class="line">财务部,韩梅梅,女</span><br><span class="line"></span><br><span class="line">&gt;&gt; cat company.csv | head -n 16 ｜ awk -F <span class="string">','</span> <span class="string">'&#123;if (NR==1) next&#125;&#123;a[$1]++;b[$1]=b[$1]","$2&#125; END &#123;for (x in a) print x "\t" a[x] "\t" b[x&#125;'</span></span><br><span class="line">技术研发部5,张三,李四,王五,李雷,tom</span><br><span class="line">财务部4,张一,李二,王三,Bob</span><br><span class="line">商务部3,张二,李三,王四</span><br><span class="line">战略部门2,张五,王六</span><br><span class="line">总裁办1,三一</span><br></pre></td></tr></table></figure><p>这里新出现了一个语法 ‘next’， 它的作用等同于 continue。这个命令出现，就不会执行后面的命令了。这里它的作用是跳过第一行，因为第一行是csv文件的header。这个例子看起来毫无意义，但是在实际处理中，特别是一些log文件，数据量几千万到亿级，用python处理代码写起来也很简单，但是论速度，肯定远远不及awk。awk处理起来很快，比常用的编程语言都要快。</p><h1 id="3-awk的正则表达式"><a href="#3-awk的正则表达式" class="headerlink" title="3. awk的正则表达式"></a>3. awk的正则表达式</h1><p>正则表达式，不管什么语言，语法都是基本一样的。在实际工作中也用过不少，却始终不够熟练，甚至有点蒙。awk我也是如此。这一部分 不详细讲解了（觉得自己讲不明白），但是写2个简单例子，也算对得起这一节。<br>下图是awk正则表达式：<br><img src="https://gitee.com/jjkkk/cloud_img/raw/master/1911/awk_re.jpg" alt><br>awk的正则表达式写在2个 / 之间：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; ls -l | awk <span class="string">'/^d/&#123;print $9&#125;'</span></span><br></pre></td></tr></table></figure><p>这个例子是输出当前目录下所有的文件夹的名称（不写结果了，可自行尝试看结果）。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; awk -F <span class="string">':'</span> <span class="string">'$5~/root/&#123;print $0&#125;'</span> /etc/passwd</span><br></pre></td></tr></table></figure><p>这个例子是以分号作为分隔符，匹配第五个字段包含‘root’的行</p><h1 id="4-多文件操作及awk运行shell命令"><a href="#4-多文件操作及awk运行shell命令" class="headerlink" title="4. 多文件操作及awk运行shell命令"></a>4. 多文件操作及awk运行shell命令</h1><h2 id="4-1-awk-多文件操作"><a href="#4-1-awk-多文件操作" class="headerlink" title="4.1 awk 多文件操作"></a>4.1 awk 多文件操作</h2><p>文章开始的时候就说过，awk的基本像是如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">'&#123;命令&#125;'</span> file1, file2, ...</span><br></pre></td></tr></table></figure><p>实际上awk是按文件循序逐行读取的，读完file1， 接着读取file2，以此类推.<br>多文件处理的一个常用操作就是多文件特定内容的merge。下面用2个例子演示一下，横向合并2个文件和根据某一列或者多列合并2个文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; cat awk_test.txt</span><br><span class="line">a,b,c,d</span><br><span class="line">e,f,g,h</span><br><span class="line"></span><br><span class="line">&gt;&gt; cat awk_test1.txt</span><br><span class="line">2,3,4,a</span><br><span class="line">1,2,3,e</span><br><span class="line"></span><br><span class="line"><span class="comment"># 横向合并2个文件</span></span><br><span class="line">&gt;&gt; awk -F <span class="string">','</span> <span class="string">'NR==FNR&#123;a[NR]=$0;next&#125;&#123;if (a[FNR]) print a[FNR] FS $0&#125;'</span> awk_test.txt awk_test1.txt <span class="comment"># 实例7</span></span><br><span class="line">a,b,c,d,2,3,4,a</span><br><span class="line">e,f,g,h,1,2,3,e</span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据某一列合并2个文件</span></span><br><span class="line">&gt;&gt; awk -F <span class="string">','</span> <span class="string">'NR==FNR&#123;a[$1]=$0;next&#125;&#123;if (a[$4]) print a[$4] FS $1 FS $2 FS $3&#125;'</span> awk_test.txt awk_test1.txt <span class="comment"># 实例8</span></span><br><span class="line">a,b,c,d,2,3,4</span><br><span class="line">e,f,g,h,1,2,3</span><br></pre></td></tr></table></figure><p>这2个例子中的简单命令直接实现了Pandas的merge、concat和join操作，关键是你可以不用安装任何包，配置任何环境。更可贵的是，速度非常快。<br><strong>通常，使用 NR==FNR 条件判断是否正在读取的在第一个文件。</strong>在实例7中，记录行数为索引，将awk_test.txt文件的数据存在数组里，当读到第二个文件，对于每一个记录行，先打印数组里存的第一个文件的数据，再打印第二个文件的内容，就实现了横向拼接。实例8原理基本相同。</p><h2 id="4-2-awk-运行shell命令"><a href="#4-2-awk-运行shell命令" class="headerlink" title="4.2 awk 运行shell命令"></a>4.2 awk 运行shell命令</h2><p>使用awk运行shell命令的基本格式是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">'&#123;system("shell 命令")&#125;'</span></span><br></pre></td></tr></table></figure><p>需要注意一点的是system里的shell命令需要写成字符串，即写在双引号里。<br>来一个最简单的例子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; awk <span class="string">'&#123;system("echo hello world")&#125;'</span> awk_test.txt</span><br><span class="line">hello world</span><br><span class="line">hello world</span><br></pre></td></tr></table></figure><p>可引导echo 命令运行成功。<br>接下来再看一个很实用的昨天，批量修改文件名.下面这个例子给除了black_test和已有后缀以外的文件名后面加上相同的后缀.txt：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; ls <span class="comment"># 查看文件或者文件夹名称</span></span><br><span class="line">test0 test1 test2 test3 test4.txt black_test</span><br><span class="line"></span><br><span class="line">&gt;&gt; ls | grep -vE <span class="string">"txt|black"</span> | awk <span class="string">'&#123;system("mv " $0 " " $0 ".txt")&#125;'</span> <span class="comment"># 方法1</span></span><br><span class="line">&gt;&gt; ls</span><br><span class="line">test0.txt test1.txt test2.txt test3.txt test4.txt black_test</span><br><span class="line"></span><br><span class="line">&gt;&gt; ls | egrep -v <span class="string">"txt|black"</span> | awk <span class="string">'&#123;system("mv " $0 " " $0 ".txt")&#125;'</span> <span class="comment"># 方法2</span></span><br><span class="line">&gt;&gt; ls</span><br><span class="line">test0.txt test1.txt test2.txt test3.txt test4.txt black_test</span><br><span class="line"></span><br><span class="line">&gt;&gt; ls | awk <span class="string">'$0 !~/txt|black/ &#123;system("mv " $0 " " $0 ".txt")&#125;'</span> <span class="comment"># 方法3</span></span><br><span class="line">&gt;&gt; ls</span><br><span class="line">test0.txt test1.txt test2.txt test3.txt test4.txt black_test</span><br></pre></td></tr></table></figure><p>这里涉及到grep的知识，列在下面：</p><ul><li><p>grep -E 用来扩展选项为正则表达式，如果使用了grep 命令的选项-E，则应该使用 | 来分割多个pattern</p></li><li><p>grep -v  实现反向操作。例如方法1中命令 ls | grep -vE “txt|black” 实现了搜索名称中既不包含txt也不包含black的文件。</p></li><li><p>egrep 等同于‘grep -E’</p><p>看了上面的grep的简介，方法1和方法2实际上是一样的。再来看后面的 “mv “ $0 “ “ $0 “.txt” 部分。这里假如$0 = “a”, 那么”mv “ $0 “ “ $0 “.txt”=”mv a a.txt”.这里需要注意的是空格，一定要记得打上。</p><p>再来看方法3，既然awk也有正则匹配， 那就完全可以省去grep，直接用awk的正则去筛选满足条件的文件名。命令 ‘$0 !~/txt|black/‘ 即实现了相同的效果。可以看一下上一节的规则。</p></li></ul><p>到这里，over！有不对的地方，欢迎提出来。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;awk 其名称的由来很简单，就是由其三个创始人Alfred Aho 、Peter Weinberger 和 Brian Kernighan 姓氏的首个字母组成。很多人都说它是一个效率神器，以前也多多少少用过它一些简单的用法。后来python一上手，pandas一用上，反而忘了它。正所谓技多不压身，这么高大上的程序语言（速度快，常用命令简单， 效率高），一定要学会它。所以这篇文章特将awk的基本语法，常用的命令以及相对应的命令记录下来，以备需要时直接复制使用。
    
    </summary>
    
    
      <category term="Code Tool" scheme="https://jkknotes.com/categories/Code-Tool/"/>
    
      <category term="命令速查" scheme="https://jkknotes.com/categories/Code-Tool/%E5%91%BD%E4%BB%A4%E9%80%9F%E6%9F%A5/"/>
    
    
      <category term="Tool" scheme="https://jkknotes.com/tags/Tool/"/>
    
      <category term="awk" scheme="https://jkknotes.com/tags/awk/"/>
    
  </entry>
  
  <entry>
    <title>Pandas那些年遇到的坑</title>
    <link href="https://jkknotes.com/pandas_%E9%82%A3%E4%BA%9B%E5%B9%B4%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91/"/>
    <id>https://jkknotes.com/pandas_那些年遇到的坑/</id>
    <published>2019-11-02T09:03:09.000Z</published>
    <updated>2019-11-03T15:13:35.868Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong>在进行数据处理和分析时，pandas就像一条高速公路，能够帮助我们快速的进行各种数据处理和分析操作。但是高速公路也可能有各种坑，一不小心就翻车。</strong></p><p>在平时的工作中，也积累了pandas处理的各种坑，记录下来，跟大家分享一下。<a id="more"></a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br></pre></td></tr></table></figure><h2 id="1-Pandas-IO中的坑"><a href="#1-Pandas-IO中的坑" class="headerlink" title="1. Pandas IO中的坑"></a>1. Pandas IO中的坑</h2><p>先从pandas的读写操作写起。使用pandas读写CSV文件的最常见的操作，即使这个最简单的操作，就很有可能掉入坑里。</p><h3 id="1-1-解决读的坑，让pandas读文件内存占用减小-80"><a href="#1-1-解决读的坑，让pandas读文件内存占用减小-80" class="headerlink" title="1.1 解决读的坑，让pandas读文件内存占用减小 80%"></a>1.1 解决读的坑，让pandas读文件内存占用减小 80%</h3><p><strong>资源总是有限的， 僧多肉少是常见的</strong></p><p>而我一次在公司的机器学习平台申请到5G内存，需要打开的csv文件只有900M，当你信心满满的使用 pandas.read_csv 去读取文件，意想不到的是<strong>内存爆了， 内存爆了，内存爆了！！！</strong><br>于是乎，就去学习了一下pandas在内存中存数据的方式，并且找到了解决方式，并很好的填了这个坑。</p><p>一般来说，用pandas处理小于100M的数据，性能不是问题。当用pandas来处理几百兆甚至几个G的数据时，将会比较耗时，同时会导致程序因内存不足而运行失败。那么怎么就解决这个问题呢，我们先来讨论一下pandas的内存使用。</p><p>如下表所示，pandas共有6种大的数据类型，在底层pandas会按照数据类型将列分组形成数据块（blocks）， 相同数据类型的列会合到一起存储。实际上，对于整型和浮点型数据，pandas将它们以 NumPy ndarray 的形式存储。</p><p>从表中可以看到，不同的存储方式所占用的内存不同。其中类型为category的数据在底层使用整型数值来表示该列的值，而不是用原值。当我们把一列转换成category类型时，pandas会用一种最省空间的int子类型去表示这一列中所有的唯一值。当一列只包含有限种值时，这种设计是很不错的。</p><p>了解到这里，<strong><em>我们是不是可以将占用内存多的数据类型转为占用内存低的数据类型，以到达减小内存的占用的目的。</em></strong></p><table><thead><tr><th>memory usage</th><th>float</th><th>int</th><th>unit</th><th>category</th><th>bool</th><th>object</th></tr></thead><tbody><tr><td>1 bytes</td><td></td><td>int8</td><td>unit8</td><td></td><td></td><td></td></tr><tr><td>2 bytes</td><td>float16</td><td>int16</td><td>unit16</td><td></td><td></td><td></td></tr><tr><td>4 bytes</td><td>float32</td><td>int32</td><td>unit32</td><td></td><td></td><td></td></tr><tr><td>8 bytes</td><td>float64</td><td>int64</td><td>unit64</td><td></td><td></td><td></td></tr><tr><td>variable</td><td>Slytherin</td><td></td><td></td><td>category</td><td>bool</td><td>object</td></tr></tbody></table><p>随便找了个数据,实际操作看一下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">data = pd.read_csv(<span class="string">'game_logs.csv'</span>)</span><br><span class="line">data.head()</span><br></pre></td></tr></table></figure><pre><code>/Users/kk_j/anaconda3/envs/python2_for_project/lib/python2.7/site-packages/IPython/core/interactiveshell.py:2717: DtypeWarning: Columns (12,13,14,15,19,20,81,83,85,87,93,94,95,96,97,98,99,100,105,106,108,109,111,112,114,115,117,118,120,121,123,124,126,127,129,130,132,133,135,136,138,139,141,142,144,145,147,148,150,151,153,154,156,157,160) have mixed types. Specify dtype option on import or set low_memory=False.  interactivity=interactivity, compiler=compiler, result=result)</code></pre><div><style>    .dataframe thead tr:only-child th {        text-align: right;    }<pre><code>.dataframe thead th {    text-align: left;}.dataframe tbody tr th {    vertical-align: top;}</code></pre><p></style></p><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>date</th>      <th>number_of_game</th>      <th>day_of_week</th>      <th>v_name</th>      <th>v_league</th>      <th>v_game_number</th>      <th>h_name</th>      <th>h_league</th>      <th>h_game_number</th>      <th>v_score</th>      <th>...</th>      <th>h_player_7_name</th>      <th>h_player_7_def_pos</th>      <th>h_player_8_id</th>      <th>h_player_8_name</th>      <th>h_player_8_def_pos</th>      <th>h_player_9_id</th>      <th>h_player_9_name</th>      <th>h_player_9_def_pos</th>      <th>additional_info</th>      <th>acquisition_info</th>    </tr>  </thead>  <tbody>    <tr>      <th>0</th>      <td>18710504</td>      <td>0</td>      <td>Thu</td>      <td>CL1</td>      <td>na</td>      <td>1</td>      <td>FW1</td>      <td>na</td>      <td>1</td>      <td>0</td>      <td>...</td>      <td>Ed Mincher</td>      <td>7.0</td>      <td>mcdej101</td>      <td>James McDermott</td>      <td>8.0</td>      <td>kellb105</td>      <td>Bill Kelly</td>      <td>9.0</td>      <td>NaN</td>      <td>Y</td>    </tr>    <tr>      <th>1</th>      <td>18710505</td>      <td>0</td>      <td>Fri</td>      <td>BS1</td>      <td>na</td>      <td>1</td>      <td>WS3</td>      <td>na</td>      <td>1</td>      <td>20</td>      <td>...</td>      <td>Asa Brainard</td>      <td>1.0</td>      <td>burrh101</td>      <td>Henry Burroughs</td>      <td>9.0</td>      <td>berth101</td>      <td>Henry Berthrong</td>      <td>8.0</td>      <td>HTBF</td>      <td>Y</td>    </tr>    <tr>      <th>2</th>      <td>18710506</td>      <td>0</td>      <td>Sat</td>      <td>CL1</td>      <td>na</td>      <td>2</td>      <td>RC1</td>      <td>na</td>      <td>1</td>      <td>12</td>      <td>...</td>      <td>Pony Sager</td>      <td>6.0</td>      <td>birdg101</td>      <td>George Bird</td>      <td>7.0</td>      <td>stirg101</td>      <td>Gat Stires</td>      <td>9.0</td>      <td>NaN</td>      <td>Y</td>    </tr>    <tr>      <th>3</th>      <td>18710508</td>      <td>0</td>      <td>Mon</td>      <td>CL1</td>      <td>na</td>      <td>3</td>      <td>CH1</td>      <td>na</td>      <td>1</td>      <td>12</td>      <td>...</td>      <td>Ed Duffy</td>      <td>6.0</td>      <td>pinke101</td>      <td>Ed Pinkham</td>      <td>5.0</td>      <td>zettg101</td>      <td>George Zettlein</td>      <td>1.0</td>      <td>NaN</td>      <td>Y</td>    </tr>    <tr>      <th>4</th>      <td>18710509</td>      <td>0</td>      <td>Tue</td>      <td>BS1</td>      <td>na</td>      <td>2</td>      <td>TRO</td>      <td>na</td>      <td>1</td>      <td>9</td>      <td>...</td>      <td>Steve Bellan</td>      <td>5.0</td>      <td>pikel101</td>      <td>Lip Pike</td>      <td>3.0</td>      <td>cravb101</td>      <td>Bill Craver</td>      <td>6.0</td>      <td>HTBF</td>      <td>Y</td>    </tr>  </tbody></table><p>5 rows × 161 columns</p></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data.info(memory_usage=<span class="string">'deep'</span>)</span><br></pre></td></tr></table></figure><pre><code>&lt;class &apos;pandas.core.frame.DataFrame&apos;&gt;RangeIndex: 171907 entries, 0 to 171906Columns: 161 entries, date to acquisition_infodtypes: float64(77), int64(6), object(78)memory usage: 738.1 MB</code></pre><p><strong><em>可以看到这个数据占用内存738.1M，而文件原来的大小仅仅128M，内存占用是原文件大小的 6 倍！！！</em></strong></p><p>再来尝试一下在打开文件的时候指定列的类型，将数据类型为object的列变成category的数据类型。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">object_cols = data.select_dtypes(include=[<span class="string">'object'</span>]).columns.tolist()</span><br><span class="line">dtype_list = [<span class="string">'category'</span> <span class="keyword">for</span> x <span class="keyword">in</span> object_cols]</span><br><span class="line">cols_dtype_dict = dict(zip(object_cols, dtype_list))</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">data1 = pd.read_csv(<span class="string">'game_logs.csv'</span>, dtype=cols_dtype_dict, date_parser=[<span class="string">'date'</span>], infer_datetime_format=<span class="literal">True</span>)</span><br><span class="line">data1.info(memory_usage=<span class="string">'deep'</span>)</span><br></pre></td></tr></table></figure><pre><code>&lt;class &apos;pandas.core.frame.DataFrame&apos;&gt;RangeIndex: 171907 entries, 0 to 171906Columns: 161 entries, date to acquisition_infodtypes: category(78), float64(77), int64(6)memory usage: 157.2 MB</code></pre><p>可以看到，<strong><em>内存占用从 738.1M 降到了157.2M，有效降低 78.7%</em></strong>， 而且那一堆Warning 也没了</p><p>很开心对不对，<strong>没有资源，咱自己创造资源</strong><br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly90aW1nc2EuYmFpZHUuY29tL3RpbWc_aW1hZ2UmcXVhbGl0eT04MCZzaXplPWI5OTk5XzEwMDAwJnNlYz0xNTU0NjM2NjI5MjM4JmRpPWI3N2Q3MWU2MzVmOGVkMmU3ZmE0MGM4NDdhYzFiODkzJmltZ3R5cGU9MCZzcmM9aHR0cDovL2Itc3NsLmR1aXRhbmcuY29tL3VwbG9hZHMvaXRlbS8yMDE3MDMvMjkvMjAxNzAzMjkxNjE3MjhfZmRTTUYudGh1bWIuMjI0XzAuZ2lm" alt=""></p><h3 id="1-2-解决写的坑，让磁盘空间节约60"><a href="#1-2-解决写的坑，让磁盘空间节约60" class="headerlink" title="1.2 解决写的坑，让磁盘空间节约60%"></a>1.2 解决写的坑，让磁盘空间节约60%</h3><p>经常听见有小伙伴说，XXXX服务器磁盘空间又满了，大家清理一下自己不用的数据，数据很重要，不能删怎么办。</p><p>还是那句话，<strong>没有资源，咱创造资源</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data1.to_csv(<span class="string">'game_logs.gz'</span>, compression=<span class="string">'gzip'</span>, index=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><p>去磁盘再去看看文件大小，是不是磁盘变大了。错了，是不是文件变小了。</p><p><strong><em>在我的电脑里，这个文件从 128M 减小到18M。我去，磁盘占用减小了86%</em></strong></p><p>那读取的时候怎么办呢，读取方式不变，还是 read_csv </p><h3 id="1-3-解决写的坑，避免挖个坑"><a href="#1-3-解决写的坑，避免挖个坑" class="headerlink" title="1.3 解决写的坑，避免挖个坑"></a>1.3 解决写的坑，避免挖个坑</h3><p>这个坑比较简单，但是一不小心就翻车。看个例子</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df = pd.DataFrame(np.random.rand(<span class="number">2</span>,<span class="number">2</span>), columns=[<span class="string">'a'</span>, <span class="string">'b'</span>])</span><br><span class="line">df</span><br></pre></td></tr></table></figure><div><style>    .dataframe thead tr:only-child th {        text-align: right;    }<pre><code>.dataframe thead th {    text-align: left;}.dataframe tbody tr th {    vertical-align: top;}</code></pre><p></style></p><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>a</th>      <th>b</th>    </tr>  </thead>  <tbody>    <tr>      <th>0</th>      <td>0.977292</td>      <td>0.343893</td>    </tr>    <tr>      <th>1</th>      <td>0.478050</td>      <td>0.781146</td>    </tr>  </tbody></table></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.to_csv(<span class="string">'test_df.csv'</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df1 = pd.read_csv(<span class="string">'test_df.csv'</span>)</span><br><span class="line">df1</span><br></pre></td></tr></table></figure><div><style>    .dataframe thead tr:only-child th {        text-align: right;    }<pre><code>.dataframe thead th {    text-align: left;}.dataframe tbody tr th {    vertical-align: top;}</code></pre><p></style></p><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>Unnamed: 0</th>      <th>a</th>      <th>b</th>    </tr>  </thead>  <tbody>    <tr>      <th>0</th>      <td>0</td>      <td>0.977292</td>      <td>0.343893</td>    </tr>    <tr>      <th>1</th>      <td>1</td>      <td>0.478050</td>      <td>0.781146</td>    </tr>  </tbody></table></div><p>通过以上例子，可以看到，<strong><em>一存一读间，却多了一列。</em></strong><br>这种情况极易给后面的操作埋下一个大坑，而且还蒙在鼓里找不出原因。</p><p>怎么解决呢，只需要在存的时候，指定 index 参数为 False 即可。再来试一下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">df.to_csv(<span class="string">'test_df.csv'</span>, index=<span class="literal">False</span>)</span><br><span class="line">df = pd.read_csv(<span class="string">'test_df.csv'</span>)</span><br><span class="line">df</span><br></pre></td></tr></table></figure><div><style>    .dataframe thead tr:only-child th {        text-align: right;    }<pre><code>.dataframe thead th {    text-align: left;}.dataframe tbody tr th {    vertical-align: top;}</code></pre><p></style></p><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>a</th>      <th>b</th>    </tr>  </thead>  <tbody>    <tr>      <th>0</th>      <td>0.977292</td>      <td>0.343893</td>    </tr>    <tr>      <th>1</th>      <td>0.478050</td>      <td>0.781146</td>    </tr>  </tbody></table></div><h3 id="1-4-python2：加上encoding，-读写好习惯"><a href="#1-4-python2：加上encoding，-读写好习惯" class="headerlink" title="1.4 python2：加上encoding， 读写好习惯"></a>1.4 python2：加上encoding， 读写好习惯</h3><p>这个就不举例子讲了。但是讲一下原因。</p><p>在工作中经常处理带中文字符的csv文件，一个好的习惯是，在使用pandas的read_csv（其他的read操作一样）进行文件读取时，<strong><em>加上参数 encoding=‘utf-8’</em></strong>，并且在数据的操作中都始终使用utf-8的编码格式，会减少非常多的坑。另外在使用 .to_csv 存储带有中文字符的DataFram数据时，加上参数 <strong><em>encoding=‘utf-8-sig’</em></strong>，这样存成的csv就可以用excel打开，而不乱码。</p><p>关于编码知识，可以看这里：<a href="https://blog.csdn.net/u010223750/article/details/56684096/" target="_blank" rel="noopener">https://blog.csdn.net/u010223750/article/details/56684096/</a></p><h3 id="1-5-乱入：用pandas进行onehot的神坑"><a href="#1-5-乱入：用pandas进行onehot的神坑" class="headerlink" title="1.5 乱入：用pandas进行onehot的神坑"></a>1.5 乱入：用pandas进行onehot的神坑</h3><p>机器学习特征工程中，经常会用到one-hot编码。并且pandas中已经提供了这一函数pandas.get_dummies()。<br><strong><em>但是使用这个函数进行one hot操作后得到的数据类型竟然是是uint8，如果进行数值计算时会溢出。</em></strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">data_df = pd.DataFrame(&#123;<span class="string">'sex'</span>: [<span class="string">'male'</span>, <span class="string">'female'</span>, <span class="string">'female'</span>, <span class="string">'female'</span>, <span class="string">'female'</span>, <span class="string">'male'</span>, <span class="string">'female'</span>],</span><br><span class="line">                        <span class="string">'height'</span>: [<span class="number">182</span>, <span class="number">160</span>, <span class="number">176</span>, <span class="number">172</span>, <span class="number">174</span>, <span class="number">170</span>, <span class="number">155</span>],</span><br><span class="line">                        <span class="string">'weight'</span>: [<span class="number">65</span>, <span class="number">50</span>, <span class="number">55</span>, <span class="number">48</span>, <span class="number">48</span>, <span class="number">100</span>, <span class="number">80</span>],</span><br><span class="line">                        <span class="string">'is_air_hostesses'</span>: [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>]&#125;)</span><br><span class="line">data_df</span><br></pre></td></tr></table></figure><div><style>    .dataframe thead tr:only-child th {        text-align: right;    }<pre><code>.dataframe thead th {    text-align: left;}.dataframe tbody tr th {    vertical-align: top;}</code></pre><p></style></p><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>height</th>      <th>is_air_hostesses</th>      <th>sex</th>      <th>weight</th>    </tr>  </thead>  <tbody>    <tr>      <th>0</th>      <td>182</td>      <td>1</td>      <td>male</td>      <td>65</td>    </tr>    <tr>      <th>1</th>      <td>160</td>      <td>1</td>      <td>female</td>      <td>50</td>    </tr>    <tr>      <th>2</th>      <td>176</td>      <td>1</td>      <td>female</td>      <td>55</td>    </tr>    <tr>      <th>3</th>      <td>172</td>      <td>1</td>      <td>female</td>      <td>48</td>    </tr>    <tr>      <th>4</th>      <td>174</td>      <td>1</td>      <td>female</td>      <td>48</td>    </tr>    <tr>      <th>5</th>      <td>170</td>      <td>0</td>      <td>male</td>      <td>100</td>    </tr>    <tr>      <th>6</th>      <td>155</td>      <td>0</td>      <td>female</td>      <td>80</td>    </tr>  </tbody></table></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sex_one_hot_df = pd.get_dummies(data_df[<span class="string">'sex'</span>])</span><br><span class="line">sex_one_hot_df</span><br></pre></td></tr></table></figure><div><style>    .dataframe thead tr:only-child th {        text-align: right;    }<pre><code>.dataframe thead th {    text-align: left;}.dataframe tbody tr th {    vertical-align: top;}</code></pre><p></style></p><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>female</th>      <th>male</th>    </tr>  </thead>  <tbody>    <tr>      <th>0</th>      <td>0</td>      <td>1</td>    </tr>    <tr>      <th>1</th>      <td>1</td>      <td>0</td>    </tr>    <tr>      <th>2</th>      <td>1</td>      <td>0</td>    </tr>    <tr>      <th>3</th>      <td>1</td>      <td>0</td>    </tr>    <tr>      <th>4</th>      <td>1</td>      <td>0</td>    </tr>    <tr>      <th>5</th>      <td>0</td>      <td>1</td>    </tr>    <tr>      <th>6</th>      <td>1</td>      <td>0</td>    </tr>  </tbody></table></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sex_one_hot_df.dtypes</span><br></pre></td></tr></table></figure><pre><code>female    uint8male      uint8dtype: object</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-sex_one_hot_df</span><br></pre></td></tr></table></figure><div><style>    .dataframe thead tr:only-child th {        text-align: right;    }<pre><code>.dataframe thead th {    text-align: left;}.dataframe tbody tr th {    vertical-align: top;}</code></pre><p></style></p><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>female</th>      <th>male</th>    </tr>  </thead>  <tbody>    <tr>      <th>0</th>      <td>0</td>      <td>255</td>    </tr>    <tr>      <th>1</th>      <td>255</td>      <td>0</td>    </tr>    <tr>      <th>2</th>      <td>255</td>      <td>0</td>    </tr>    <tr>      <th>3</th>      <td>255</td>      <td>0</td>    </tr>    <tr>      <th>4</th>      <td>255</td>      <td>0</td>    </tr>    <tr>      <th>5</th>      <td>0</td>      <td>255</td>    </tr>    <tr>      <th>6</th>      <td>255</td>      <td>0</td>    </tr>  </tbody></table></div><p>这真的是一个神坑，如果特征比较多的话，根本发现不了。如果没有发现，后续如果做其他操的时候，就会出错。这个坑藏得深啊。</p><p>正确的做法是转换一下数据类型：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sex_one_hot_df = sex_one_hot_df.astype(<span class="string">'float'</span>)</span><br></pre></td></tr></table></figure><h2 id="2-DataFrame-链式索引的坑"><a href="#2-DataFrame-链式索引的坑" class="headerlink" title="2. DataFrame 链式索引的坑"></a>2. DataFrame 链式索引的坑</h2><h3 id="2-1-解决：SettingWithCopyWarning"><a href="#2-1-解决：SettingWithCopyWarning" class="headerlink" title="2.1 解决：SettingWithCopyWarning:"></a>2.1 解决：SettingWithCopyWarning:</h3><p><strong>SettingWithCopyWarning</strong> 可能是人们在学习 Pandas 时遇到的最常见的障碍之一。<br>首先来看看，它出现的情况之一（其他情况大同小异）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sub_df = df.loc[df.a &gt; <span class="number">0.6</span>]</span><br><span class="line">sub_df</span><br></pre></td></tr></table></figure><div><style>    .dataframe thead tr:only-child th {        text-align: right;    }<pre><code>.dataframe thead th {    text-align: left;}.dataframe tbody tr th {    vertical-align: top;}</code></pre><p></style></p><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>a</th>      <th>b</th>    </tr>  </thead>  <tbody>    <tr>      <th>0</th>      <td>0.688818</td>      <td>0.510446</td>    </tr>    <tr>      <th>4</th>      <td>0.945565</td>      <td>0.801788</td>    </tr>  </tbody></table></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sub_df[<span class="string">'c'</span>] = [<span class="number">1</span>,<span class="number">2</span>]</span><br></pre></td></tr></table></figure><pre><code>/Users/kk_j/anaconda3/envs/python2_for_project/lib/python2.7/site-packages/ipykernel_launcher.py:1: SettingWithCopyWarning: A value is trying to be set on a copy of a slice from a DataFrame.Try using .loc[row_indexer,col_indexer] = value insteadSee the caveats in the documentation: http://pandas.pydata.org/pandas-docs/stable/indexing.html#indexing-view-versus-copy  &quot;&quot;&quot;Entry point for launching an IPython kernel.</code></pre><p>没有出任何意外，SettingWithCopyWarning 出现。首先要理解的是，SettingWithCopyWarning 是一个警告 Warning，而不是错误 Error，它告诉你，你的操作可能没有按预期运行，需要检查结果以确保没有出错。<strong><em>当你查看结果，发现结果没有错，就是在按预期进行，你极有可能忽略这个Warning, 而当下次它再次出现时，你不会再检查，然后错误就出现了。</em></strong></p><p>直接说他出现的原因，那就是<strong><em>链式索引产生的新的变量并没有在内存中创建副本，当接下来对新的变量进行修改时，有修改原数据的风险。</em></strong></p><p>怎么解决呢。很简单,只需要在链式索引后面加上一个.copy() 即可：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sub_df = df.loc[df.a &gt; <span class="number">0.6</span>].copy()</span><br><span class="line">sub_df[<span class="string">'c'</span>] = [<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">sub_df</span><br></pre></td></tr></table></figure><div><style>    .dataframe thead tr:only-child th {        text-align: right;    }<pre><code>.dataframe thead th {    text-align: left;}.dataframe tbody tr th {    vertical-align: top;}</code></pre><p></style></p><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>a</th>      <th>b</th>      <th>c</th>    </tr>  </thead>  <tbody>    <tr>      <th>0</th>      <td>0.688818</td>      <td>0.510446</td>      <td>1</td>    </tr>    <tr>      <th>4</th>      <td>0.945565</td>      <td>0.801788</td>      <td>2</td>    </tr>  </tbody></table></div><p>再试试，可以看到没有再出现问题。</p><p>但是我们也注意到，在Warning的提示里，提到：<strong>Try using .loc[row_indexer,col_indexer] = value instead</strong>。这也是一种解决办法，当你仅仅是想更改原始数据，你可以使用这个操作。</p><p>对这个问题的详细原理讲解，请参考： <a href="https://www.dataquest.io/blog/settingwithcopywarning/" target="_blank" rel="noopener">https://www.dataquest.io/blog/settingwithcopywarning/</a></p><h3 id="2-2-DataFrame-里存None：这个坑是真的坑"><a href="#2-2-DataFrame-里存None：这个坑是真的坑" class="headerlink" title="2.2 DataFrame 里存None：这个坑是真的坑"></a>2.2 DataFrame 里存None：这个坑是真的坑</h3><p>真的不好写开场白，直接上例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">v = &#123;<span class="string">'value'</span>: <span class="string">'a'</span>&#125;</span><br><span class="line">d = [&#123;<span class="string">'name'</span>: <span class="string">'class'</span>, <span class="string">'age'</span>: <span class="number">10</span>&#125;, &#123;<span class="string">'name'</span>: <span class="literal">None</span>, <span class="string">'age'</span>: <span class="number">11</span>&#125;, &#123;<span class="string">'name'</span>: <span class="string">'def'</span>, <span class="string">'age'</span>: <span class="number">9</span>&#125;]</span><br><span class="line">df = pd.DataFrame(d)</span><br><span class="line"></span><br><span class="line">new_1 = df[(df[<span class="string">'age'</span>] &gt;= <span class="number">10</span>) | df[<span class="string">'name'</span>].str.contains(v[<span class="string">'value'</span>])]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 颠倒里面条件的顺序</span></span><br><span class="line">new_2 = df[df[<span class="string">'name'</span>].str.contains(v[<span class="string">'value'</span>]) | (df[<span class="string">'age'</span>] &gt;= <span class="number">10</span>)]</span><br><span class="line"></span><br><span class="line">print(<span class="string">'-'</span>*<span class="number">40</span>)</span><br><span class="line">print(df)</span><br><span class="line"></span><br><span class="line">print(<span class="string">'-'</span>*<span class="number">40</span>)</span><br><span class="line">print(new_1)</span><br><span class="line"></span><br><span class="line">print(<span class="string">'-'</span>*<span class="number">40</span>)</span><br><span class="line">print(new_2)</span><br></pre></td></tr></table></figure><pre><code>----------------------------------------   age   name0   10  class1   11   None2    9    def----------------------------------------   age   name0   10  class1   11   None----------------------------------------   age   name0   10  class</code></pre><p>这。。。。。逻辑操作“或”俩边的条件对调下，结果也能不一样？一脸懵逼。</p><p>但是接下来，我进行了简单的探索。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df[<span class="string">'age'</span>] &gt;= <span class="number">10</span></span><br></pre></td></tr></table></figure><pre><code>0     True1     True2    FalseName: age, dtype: bool</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df[<span class="string">'name'</span>].str.contains(v[<span class="string">'value'</span>])</span><br></pre></td></tr></table></figure><pre><code>0     True1     None2    FalseName: name, dtype: object</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(df[<span class="string">'age'</span>] &gt;= <span class="number">10</span>) | df[<span class="string">'name'</span>].str.contains(v[<span class="string">'value'</span>])</span><br></pre></td></tr></table></figure><pre><code>0     True1     True2    Falsedtype: bool</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df[<span class="string">'name'</span>].str.contains(v[<span class="string">'value'</span>]) | (df[<span class="string">'age'</span>] &gt;= <span class="number">10</span>)</span><br></pre></td></tr></table></figure><pre><code>0     True1    False2    Falsedtype: bool</code></pre><p>这。。。。。。还是一脸懵逼。</p><p><strong><em>百度了一圈，还是没有找到答案。但是找到了解决了办法：<br>把 None 改为了 ‘’ 就可以了。</em></strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">v = &#123;<span class="string">'value'</span>: <span class="string">'a'</span>&#125;</span><br><span class="line">d = [&#123;<span class="string">'name'</span>: <span class="string">'class'</span>, <span class="string">'age'</span>: <span class="number">10</span>&#125;, &#123;<span class="string">'name'</span>: <span class="string">''</span>, <span class="string">'age'</span>: <span class="number">11</span>&#125;, &#123;<span class="string">'name'</span>: <span class="string">'def'</span>, <span class="string">'age'</span>: <span class="number">9</span>&#125;]</span><br><span class="line">df = pd.DataFrame(d)</span><br><span class="line"></span><br><span class="line">new_1 = df[(df[<span class="string">'age'</span>] &gt;= <span class="number">10</span>) | df[<span class="string">'name'</span>].str.contains(v[<span class="string">'value'</span>])]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 颠倒里面条件的顺序</span></span><br><span class="line">new_2 = df[df[<span class="string">'name'</span>].str.contains(v[<span class="string">'value'</span>]) | (df[<span class="string">'age'</span>] &gt;= <span class="number">10</span>)]</span><br><span class="line"></span><br><span class="line">print(<span class="string">'-'</span>*<span class="number">40</span>)</span><br><span class="line">print(df)</span><br><span class="line"></span><br><span class="line">print(<span class="string">'-'</span>*<span class="number">40</span>)</span><br><span class="line">print(new_1)</span><br><span class="line"></span><br><span class="line">print(<span class="string">'-'</span>*<span class="number">40</span>)</span><br><span class="line">print(new_2)</span><br></pre></td></tr></table></figure><pre><code>----------------------------------------   age   name0   10  class1   11       2    9    def----------------------------------------   age   name0   10  class1   11       ----------------------------------------   age   name0   10  class1   11       </code></pre><h3 id="2-3-这个坑不算坑"><a href="#2-3-这个坑不算坑" class="headerlink" title="2.3 这个坑不算坑"></a>2.3 这个坑不算坑</h3><p>这里就举个例子，自己体会：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">print</span> type(df[<span class="string">'age'</span>])</span><br><span class="line">df[<span class="string">'age'</span>]</span><br></pre></td></tr></table></figure><pre><code>&lt;class &apos;pandas.core.series.Series&apos;&gt;0    101    112     9Name: age, dtype: int64</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">print</span> type(df[[<span class="string">'age'</span>]])</span><br><span class="line">df[[<span class="string">'age'</span>]]</span><br></pre></td></tr></table></figure><pre><code>&lt;class &apos;pandas.core.frame.DataFrame&apos;&gt;</code></pre><div><style>    .dataframe thead tr:only-child th {        text-align: right;    }<pre><code>.dataframe thead th {    text-align: left;}.dataframe tbody tr th {    vertical-align: top;}</code></pre><p></style></p><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>age</th>    </tr>  </thead>  <tbody>    <tr>      <th>0</th>      <td>10</td>    </tr>    <tr>      <th>1</th>      <td>11</td>    </tr>    <tr>      <th>2</th>      <td>9</td>    </tr>  </tbody></table></div><p><strong><em>前面是Series后面是DataFrame，这不知道算不算一个坑</em></strong></p><h2 id="3-DataFrame-拼接里面的坑与技巧"><a href="#3-DataFrame-拼接里面的坑与技巧" class="headerlink" title="3. DataFrame 拼接里面的坑与技巧"></a>3. DataFrame 拼接里面的坑与技巧</h2><p>pandas 里多个DataFrame的拼接，主要是append， merge，concat，join四个函数。想详细了解的话看一下官方文档。</p><p><strong><em>这里简单说一下concat和merge.</em></strong></p><h3 id="3-1-concat：坑虽小，须谨慎"><a href="#3-1-concat：坑虽小，须谨慎" class="headerlink" title="3.1 concat：坑虽小，须谨慎"></a>3.1 concat：坑虽小，须谨慎</h3><p>解释这个坑，也只有靠例子。直接上代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">df1 = pd.DataFrame(&#123; <span class="string">'A'</span>: [<span class="string">'A0'</span>, <span class="string">'A1'</span>, <span class="string">'A2'</span>],</span><br><span class="line">                     <span class="string">'B'</span>: [<span class="string">'B0'</span>, <span class="string">'B1'</span>, <span class="string">'B2'</span>],</span><br><span class="line">                     <span class="string">'C'</span>: [<span class="string">'C0'</span>, <span class="string">'C1'</span>, <span class="string">'C2'</span>],</span><br><span class="line">                     <span class="string">'D'</span>: [<span class="string">'D0'</span>, <span class="string">'D1'</span>, <span class="string">'D2'</span>]&#125;)</span><br><span class="line">                     </span><br><span class="line">df2 = pd.DataFrame(&#123;<span class="string">'A'</span>: [<span class="string">'A4'</span>, <span class="string">'A5'</span>, <span class="string">'A6'</span>],</span><br><span class="line">                     <span class="string">'B'</span>: [<span class="string">'B4'</span>, <span class="string">'B5'</span>, <span class="string">'B6'</span>],</span><br><span class="line">                     <span class="string">'C'</span>: [<span class="string">'C4'</span>, <span class="string">'C5'</span>, <span class="string">'C6'</span>],</span><br><span class="line">                     <span class="string">'D'</span>: [<span class="string">'D4'</span>, <span class="string">'D5'</span>, <span class="string">'D6'</span>]&#125;)</span><br><span class="line">                     </span><br><span class="line">df3 = pd.DataFrame(&#123;<span class="string">'A'</span>: [<span class="string">'A8'</span>, <span class="string">'A9'</span>, <span class="string">'A10'</span>],</span><br><span class="line">                     <span class="string">'B'</span>: [<span class="string">'B8'</span>, <span class="string">'B9'</span>, <span class="string">'B10'</span>],</span><br><span class="line">                     <span class="string">'C'</span>: [<span class="string">'C8'</span>, <span class="string">'C9'</span>, <span class="string">'C10'</span>],</span><br><span class="line">                     <span class="string">'D'</span>: [<span class="string">'D8'</span>, <span class="string">'D9'</span>, <span class="string">'D10'</span>]&#125;)</span><br><span class="line"> </span><br><span class="line">frames = [df1, df2, df3]</span><br><span class="line">result = pd.concat(frames)</span><br><span class="line">result</span><br></pre></td></tr></table></figure><div><style>    .dataframe thead tr:only-child th {        text-align: right;    }<pre><code>.dataframe thead th {    text-align: left;}.dataframe tbody tr th {    vertical-align: top;}</code></pre><p></style></p><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>A</th>      <th>B</th>      <th>C</th>      <th>D</th>    </tr>  </thead>  <tbody>    <tr>      <th>0</th>      <td>A0</td>      <td>B0</td>      <td>C0</td>      <td>D0</td>    </tr>    <tr>      <th>1</th>      <td>A1</td>      <td>B1</td>      <td>C1</td>      <td>D1</td>    </tr>    <tr>      <th>2</th>      <td>A2</td>      <td>B2</td>      <td>C2</td>      <td>D2</td>    </tr>    <tr>      <th>0</th>      <td>A4</td>      <td>B4</td>      <td>C4</td>      <td>D4</td>    </tr>    <tr>      <th>1</th>      <td>A5</td>      <td>B5</td>      <td>C5</td>      <td>D5</td>    </tr>    <tr>      <th>2</th>      <td>A6</td>      <td>B6</td>      <td>C6</td>      <td>D6</td>    </tr>    <tr>      <th>0</th>      <td>A8</td>      <td>B8</td>      <td>C8</td>      <td>D8</td>    </tr>    <tr>      <th>1</th>      <td>A9</td>      <td>B9</td>      <td>C9</td>      <td>D9</td>    </tr>    <tr>      <th>2</th>      <td>A10</td>      <td>B10</td>      <td>C10</td>      <td>D10</td>    </tr>  </tbody></table></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">df4 = pd.DataFrame(&#123;<span class="string">'val'</span>:[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>],<span class="string">'A'</span>: [<span class="string">'A0'</span>, <span class="string">'A1'</span>, <span class="string">'A2'</span>, <span class="string">'A3'</span>,<span class="string">'A4'</span>, <span class="string">'A5'</span>, <span class="string">'A6'</span>, <span class="string">'A7'</span>,<span class="string">'A8'</span>]&#125;)</span><br><span class="line">result[<span class="string">'val'</span>] = df4[<span class="string">'A'</span>]</span><br><span class="line">result</span><br></pre></td></tr></table></figure><div><style>    .dataframe thead tr:only-child th {        text-align: right;    }<pre><code>.dataframe thead th {    text-align: left;}.dataframe tbody tr th {    vertical-align: top;}</code></pre><p></style></p><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>A</th>      <th>B</th>      <th>C</th>      <th>D</th>      <th>val</th>    </tr>  </thead>  <tbody>    <tr>      <th>0</th>      <td>A0</td>      <td>B0</td>      <td>C0</td>      <td>D0</td>      <td>A0</td>    </tr>    <tr>      <th>1</th>      <td>A1</td>      <td>B1</td>      <td>C1</td>      <td>D1</td>      <td>A1</td>    </tr>    <tr>      <th>2</th>      <td>A2</td>      <td>B2</td>      <td>C2</td>      <td>D2</td>      <td>A2</td>    </tr>    <tr>      <th>0</th>      <td>A4</td>      <td>B4</td>      <td>C4</td>      <td>D4</td>      <td>A0</td>    </tr>    <tr>      <th>1</th>      <td>A5</td>      <td>B5</td>      <td>C5</td>      <td>D5</td>      <td>A1</td>    </tr>    <tr>      <th>2</th>      <td>A6</td>      <td>B6</td>      <td>C6</td>      <td>D6</td>      <td>A2</td>    </tr>    <tr>      <th>0</th>      <td>A8</td>      <td>B8</td>      <td>C8</td>      <td>D8</td>      <td>A0</td>    </tr>    <tr>      <th>1</th>      <td>A9</td>      <td>B9</td>      <td>C9</td>      <td>D9</td>      <td>A1</td>    </tr>    <tr>      <th>2</th>      <td>A10</td>      <td>B10</td>      <td>C10</td>      <td>D10</td>      <td>A2</td>    </tr>  </tbody></table></div><p><strong><em>注意看最后一列 ‘val’ ，和我们预期（预期的是从 A0-A8 ）的真的不一样。原来赋值操作是按照index赋值的，结果就是这么出乎我们的意料。</em></strong></p><p>其实，concat的时候加上参数 <strong><em>ignore_index=True</em></strong> 就好了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">result = pd.concat(frames, ignore_index=<span class="literal">True</span>)</span><br><span class="line">result</span><br></pre></td></tr></table></figure><div><style>    .dataframe thead tr:only-child th {        text-align: right;    }<pre><code>.dataframe thead th {    text-align: left;}.dataframe tbody tr th {    vertical-align: top;}</code></pre><p></style></p><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>A</th>      <th>B</th>      <th>C</th>      <th>D</th>    </tr>  </thead>  <tbody>    <tr>      <th>0</th>      <td>A0</td>      <td>B0</td>      <td>C0</td>      <td>D0</td>    </tr>    <tr>      <th>1</th>      <td>A1</td>      <td>B1</td>      <td>C1</td>      <td>D1</td>    </tr>    <tr>      <th>2</th>      <td>A2</td>      <td>B2</td>      <td>C2</td>      <td>D2</td>    </tr>    <tr>      <th>3</th>      <td>A4</td>      <td>B4</td>      <td>C4</td>      <td>D4</td>    </tr>    <tr>      <th>4</th>      <td>A5</td>      <td>B5</td>      <td>C5</td>      <td>D5</td>    </tr>    <tr>      <th>5</th>      <td>A6</td>      <td>B6</td>      <td>C6</td>      <td>D6</td>    </tr>    <tr>      <th>6</th>      <td>A8</td>      <td>B8</td>      <td>C8</td>      <td>D8</td>    </tr>    <tr>      <th>7</th>      <td>A9</td>      <td>B9</td>      <td>C9</td>      <td>D9</td>    </tr>    <tr>      <th>8</th>      <td>A10</td>      <td>B10</td>      <td>C10</td>      <td>D10</td>    </tr>  </tbody></table></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">result[<span class="string">'val'</span>] = df4[<span class="string">'A'</span>]</span><br><span class="line">result</span><br></pre></td></tr></table></figure><div><style>    .dataframe thead tr:only-child th {        text-align: right;    }<pre><code>.dataframe thead th {    text-align: left;}.dataframe tbody tr th {    vertical-align: top;}</code></pre><p></style></p><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>A</th>      <th>B</th>      <th>C</th>      <th>D</th>      <th>val</th>    </tr>  </thead>  <tbody>    <tr>      <th>0</th>      <td>A0</td>      <td>B0</td>      <td>C0</td>      <td>D0</td>      <td>A0</td>    </tr>    <tr>      <th>1</th>      <td>A1</td>      <td>B1</td>      <td>C1</td>      <td>D1</td>      <td>A1</td>    </tr>    <tr>      <th>2</th>      <td>A2</td>      <td>B2</td>      <td>C2</td>      <td>D2</td>      <td>A2</td>    </tr>    <tr>      <th>3</th>      <td>A4</td>      <td>B4</td>      <td>C4</td>      <td>D4</td>      <td>A3</td>    </tr>    <tr>      <th>4</th>      <td>A5</td>      <td>B5</td>      <td>C5</td>      <td>D5</td>      <td>A4</td>    </tr>    <tr>      <th>5</th>      <td>A6</td>      <td>B6</td>      <td>C6</td>      <td>D6</td>      <td>A5</td>    </tr>    <tr>      <th>6</th>      <td>A8</td>      <td>B8</td>      <td>C8</td>      <td>D8</td>      <td>A6</td>    </tr>    <tr>      <th>7</th>      <td>A9</td>      <td>B9</td>      <td>C9</td>      <td>D9</td>      <td>A7</td>    </tr>    <tr>      <th>8</th>      <td>A10</td>      <td>B10</td>      <td>C10</td>      <td>D10</td>      <td>A8</td>    </tr>  </tbody></table></div><h3 id="3-2-merge：小众的技巧"><a href="#3-2-merge：小众的技巧" class="headerlink" title="3.2 merge：小众的技巧"></a>3.2 merge：小众的技巧</h3><p><a href="https://pandas.pydata.org/pandas-docs/version/0.23.4/generated/pandas.merge.html" target="_blank" rel="noopener">panda.merge</a> 这个是pandas最常用的操作之一，具体用法可以看官方文档。这里有个小的tricks, 在做一些统计分析的时候很有用。还是具体看例子吧。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">left = pd.DataFrame(&#123;<span class="string">'key'</span>: [<span class="string">'key1'</span>, <span class="string">'key2'</span>, <span class="string">'key3'</span>, <span class="string">'key4'</span>], <span class="string">'val_l'</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]&#125;)</span><br><span class="line">left</span><br></pre></td></tr></table></figure><div><style>    .dataframe thead tr:only-child th {        text-align: right;    }<pre><code>.dataframe thead th {    text-align: left;}.dataframe tbody tr th {    vertical-align: top;}</code></pre><p></style></p><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>key</th>      <th>val_l</th>    </tr>  </thead>  <tbody>    <tr>      <th>0</th>      <td>key1</td>      <td>1</td>    </tr>    <tr>      <th>1</th>      <td>key2</td>      <td>2</td>    </tr>    <tr>      <th>2</th>      <td>key3</td>      <td>3</td>    </tr>    <tr>      <th>3</th>      <td>key4</td>      <td>4</td>    </tr>  </tbody></table></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">right = pd.DataFrame(&#123;<span class="string">'key'</span>: [<span class="string">'key3'</span>, <span class="string">'key2'</span>, <span class="string">'key1'</span>, <span class="string">'key6'</span>], <span class="string">'val_r'</span>: [<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">6</span>]&#125;)</span><br><span class="line">right</span><br></pre></td></tr></table></figure><div><style>    .dataframe thead tr:only-child th {        text-align: right;    }<pre><code>.dataframe thead th {    text-align: left;}.dataframe tbody tr th {    vertical-align: top;}</code></pre><p></style></p><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>key</th>      <th>val_r</th>    </tr>  </thead>  <tbody>    <tr>      <th>0</th>      <td>key3</td>      <td>3</td>    </tr>    <tr>      <th>1</th>      <td>key2</td>      <td>2</td>    </tr>    <tr>      <th>2</th>      <td>key1</td>      <td>1</td>    </tr>    <tr>      <th>3</th>      <td>key6</td>      <td>6</td>    </tr>  </tbody></table></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df_merge = pd.merge(left, right, on=<span class="string">'key'</span>, how=<span class="string">'left'</span>, indicator=<span class="literal">True</span>)</span><br><span class="line">df_merge</span><br></pre></td></tr></table></figure><div><style>    .dataframe thead tr:only-child th {        text-align: right;    }<pre><code>.dataframe thead th {    text-align: left;}.dataframe tbody tr th {    vertical-align: top;}</code></pre><p></style></p><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>key</th>      <th>val_l</th>      <th>val_r</th>      <th>_merge</th>    </tr>  </thead>  <tbody>    <tr>      <th>0</th>      <td>key1</td>      <td>1</td>      <td>1.0</td>      <td>both</td>    </tr>    <tr>      <th>1</th>      <td>key2</td>      <td>2</td>      <td>2.0</td>      <td>both</td>    </tr>    <tr>      <th>2</th>      <td>key3</td>      <td>3</td>      <td>3.0</td>      <td>both</td>    </tr>    <tr>      <th>3</th>      <td>key4</td>      <td>4</td>      <td>NaN</td>      <td>left_only</td>    </tr>  </tbody></table></div><p><strong>_merge 列不仅可以用来检查是否出现数值错误，还可以进行统计分析，比如：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df_merge[<span class="string">'_merge'</span>].value_counts()</span><br></pre></td></tr></table></figure><pre><code>both          3left_only     1right_only    0Name: _merge, dtype: int64</code></pre><h2 id="4-一些技巧"><a href="#4-一些技巧" class="headerlink" title="4. 一些技巧"></a>4. 一些技巧</h2><p>技巧总是讲不完，我这里随便再写点。</p><h3 id="4-1-pandas-画图"><a href="#4-1-pandas-画图" class="headerlink" title="4.1 pandas 画图"></a>4.1 pandas 画图</h3><p>这个举个例子就好了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line">df_merge.val_l.plot(kind=<span class="string">'bar'</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><img src="https://gitee.com/jjkkk/cloud_img/raw/master/1911/output_74_0.png" alt><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">data1.plot(kind=<span class="string">'scatter'</span>, x=<span class="string">'v_game_number'</span>, y=<span class="string">'v_score'</span>, alpha=<span class="number">0.1</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><img src="https://gitee.com/jjkkk/cloud_img/raw/master/1911/output_75_0.png" alt><p>plot这个命令底层调用的就是matplotlib。必须事先装好matplotlib，不然会报错。</p><p><strong><em>这里的 2 个例子只是抛砖引玉，真正的功能非常强大，有兴趣的小伙伴可以学习一下</em></strong></p><h3 id="4-2-简单的相关性分析"><a href="#4-2-简单的相关性分析" class="headerlink" title="4.2 简单的相关性分析"></a>4.2 简单的相关性分析</h3><p>写到这里，写累了。不想去找数据集，还是用前面自己构造的数据集演示一下这个小技巧：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">data_df = pd.DataFrame(&#123;<span class="string">'sex'</span>: [<span class="string">'male'</span>, <span class="string">'female'</span>, <span class="string">'female'</span>, <span class="string">'female'</span>, <span class="string">'female'</span>, <span class="string">'male'</span>, <span class="string">'female'</span>],</span><br><span class="line">                        <span class="string">'height'</span>: [<span class="number">182</span>, <span class="number">160</span>, <span class="number">176</span>, <span class="number">172</span>, <span class="number">174</span>, <span class="number">170</span>, <span class="number">155</span>],</span><br><span class="line">                        <span class="string">'weight'</span>: [<span class="number">65</span>, <span class="number">50</span>, <span class="number">55</span>, <span class="number">48</span>, <span class="number">48</span>, <span class="number">100</span>, <span class="number">80</span>],</span><br><span class="line">                        <span class="string">'is_air_hostesses'</span>: [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>]&#125;)</span><br><span class="line">data_df</span><br></pre></td></tr></table></figure><div><style>    .dataframe thead tr:only-child th {        text-align: right;    }<pre><code>.dataframe thead th {    text-align: left;}.dataframe tbody tr th {    vertical-align: top;}</code></pre><p></style></p><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>height</th>      <th>is_air_hostesses</th>      <th>sex</th>      <th>weight</th>    </tr>  </thead>  <tbody>    <tr>      <th>0</th>      <td>182</td>      <td>1</td>      <td>male</td>      <td>65</td>    </tr>    <tr>      <th>1</th>      <td>160</td>      <td>1</td>      <td>female</td>      <td>50</td>    </tr>    <tr>      <th>2</th>      <td>176</td>      <td>1</td>      <td>female</td>      <td>55</td>    </tr>    <tr>      <th>3</th>      <td>172</td>      <td>1</td>      <td>female</td>      <td>48</td>    </tr>    <tr>      <th>4</th>      <td>174</td>      <td>1</td>      <td>female</td>      <td>48</td>    </tr>    <tr>      <th>5</th>      <td>170</td>      <td>0</td>      <td>male</td>      <td>100</td>    </tr>    <tr>      <th>6</th>      <td>155</td>      <td>0</td>      <td>female</td>      <td>80</td>    </tr>  </tbody></table></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data_df[[<span class="string">'sex'</span>, <span class="string">'is_air_hostesses'</span>]].groupby([<span class="string">'sex'</span>], as_index=<span class="literal">False</span>).mean().sort_values(by=<span class="string">'is_air_hostesses'</span>, ascending=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><div><style>    .dataframe thead tr:only-child th {        text-align: right;    }<pre><code>.dataframe thead th {    text-align: left;}.dataframe tbody tr th {    vertical-align: top;}</code></pre><p></style></p><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>sex</th>      <th>is_air_hostesses</th>    </tr>  </thead>  <tbody>    <tr>      <th>0</th>      <td>female</td>      <td>0.8</td>    </tr>    <tr>      <th>1</th>      <td>male</td>      <td>0.5</td>    </tr>  </tbody></table></div><p><strong>* 可以看到女生做空乘的可能性更大一些 *</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">data_df[<span class="string">'height_band'</span>] = pd.qcut(data_df[<span class="string">'height'</span>], <span class="number">2</span>)</span><br><span class="line">data_df</span><br></pre></td></tr></table></figure><div><style>    .dataframe thead tr:only-child th {        text-align: right;    }<pre><code>.dataframe thead th {    text-align: left;}.dataframe tbody tr th {    vertical-align: top;}</code></pre><p></style></p><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>height</th>      <th>is_air_hostesses</th>      <th>sex</th>      <th>weight</th>      <th>height_band</th>    </tr>  </thead>  <tbody>    <tr>      <th>0</th>      <td>182</td>      <td>1</td>      <td>male</td>      <td>65</td>      <td>(172.0, 182.0]</td>    </tr>    <tr>      <th>1</th>      <td>160</td>      <td>1</td>      <td>female</td>      <td>50</td>      <td>(154.999, 172.0]</td>    </tr>    <tr>      <th>2</th>      <td>176</td>      <td>1</td>      <td>female</td>      <td>55</td>      <td>(172.0, 182.0]</td>    </tr>    <tr>      <th>3</th>      <td>172</td>      <td>1</td>      <td>female</td>      <td>48</td>      <td>(154.999, 172.0]</td>    </tr>    <tr>      <th>4</th>      <td>174</td>      <td>1</td>      <td>female</td>      <td>48</td>      <td>(172.0, 182.0]</td>    </tr>    <tr>      <th>5</th>      <td>170</td>      <td>0</td>      <td>male</td>      <td>100</td>      <td>(154.999, 172.0]</td>    </tr>    <tr>      <th>6</th>      <td>155</td>      <td>0</td>      <td>female</td>      <td>80</td>      <td>(154.999, 172.0]</td>    </tr>  </tbody></table></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">data_df[[<span class="string">'height_band'</span>, <span class="string">'is_air_hostesses'</span>]].groupby([<span class="string">'height_band'</span>], as_index=<span class="literal">False</span>).mean().sort_values(by=<span class="string">'is_air_hostesses'</span>, ascending=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><div><style>    .dataframe thead tr:only-child th {        text-align: right;    }<pre><code>.dataframe thead th {    text-align: left;}.dataframe tbody tr th {    vertical-align: top;}</code></pre><p></style></p><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>height_band</th>      <th>is_air_hostesses</th>    </tr>  </thead>  <tbody>    <tr>      <th>1</th>      <td>(172.0, 182.0]</td>      <td>1.0</td>    </tr>    <tr>      <th>0</th>      <td>(154.999, 172.0]</td>      <td>0.5</td>    </tr>  </tbody></table></div><p><strong>这里可以看到身高大于172的是空乘的可能性更大一些</strong></p><p>同样的也是为了抛砖引玉，不详细介绍了</p><h2 id="5-结束语"><a href="#5-结束语" class="headerlink" title="5. 结束语"></a>5. 结束语</h2><p>写pandas的这些坑，只是为了更好的提高工作效率，有兴趣的小伙伴可以学一学，相信会很有帮助。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;在进行数据处理和分析时，pandas就像一条高速公路，能够帮助我们快速的进行各种数据处理和分析操作。但是高速公路也可能有各种坑，一不小心就翻车。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在平时的工作中，也积累了pandas处理的各种坑，记录下来，跟大家分享一下。
    
    </summary>
    
    
      <category term="Code Tool" scheme="https://jkknotes.com/categories/Code-Tool/"/>
    
      <category term="Code 总结" scheme="https://jkknotes.com/categories/Code-Tool/Code-%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="Tool" scheme="https://jkknotes.com/tags/Tool/"/>
    
      <category term="Pandas" scheme="https://jkknotes.com/tags/Pandas/"/>
    
  </entry>
  
  <entry>
    <title>Git基本命令大全</title>
    <link href="https://jkknotes.com/Git%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/"/>
    <id>https://jkknotes.com/Git基本命令大全/</id>
    <published>2019-06-04T04:29:29.000Z</published>
    <updated>2019-11-03T12:53:43.551Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>Git —— 大名鼎鼎的分布式版本控制系统，据说是Linux系统之父Linus花两周时间写出来的，怎一个牛字了得。<br>写过代码的人大都知道它，以写代码为生的人大都离不开它。<br>官方文档实在太难用，这里参考大佬<a href="https://www.liaoxuefeng.com/wiki/896043488029600" target="_blank" rel="noopener"><strong>廖雪峰的教程</strong></a>，把常用命令总结写两下来，以供自己和一起搬砖的朋友备查。<a id="more"></a></p><p>这里先介绍本地仓库的常用命令，再介绍涉及远程仓库和分支管理的常用命令。本文没有实例介绍讲解，只做命令备查。如需详细教程，请参考<a href="https://www.liaoxuefeng.com/wiki/896043488029600" target="_blank" rel="noopener"><strong>廖雪峰的Git教程</strong></a>。</p><p><strong><em>本文同步发在我的<a href="https://blog.csdn.net/iizhuzhu/article/details/90760926" target="_blank" rel="noopener">CSDN Blog</a>，欢迎各位看官大佬关注指教。</em></strong></p><h2 id="1-基本操作"><a href="#1-基本操作" class="headerlink" title="1.基本操作"></a>1.基本操作</h2><h3 id="创建版本库并添加文件"><a href="#创建版本库并添加文件" class="headerlink" title="创建版本库并添加文件"></a>创建版本库并添加文件</h3><p>进入到需要<strong>创建版本库</strong>的文件夹，执行以下命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure><p>git的本地库包含三部分：工作区、暂存区（stage）、分支（branch，默认为master），git add命令是将文件从工作区添加到暂存区，git commit命令是将文件从暂存区添加到分支，他们的关系如下图所示：<br><img src="https://gitee.com/jjkkk/cloud_img/raw/master/1906/a2.jpeg" alt><br><strong>添加新文件或修改过的文件</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add file1_name file2_name file3_name ....</span><br><span class="line">git commit -m <span class="string">'这里是对添加文件的说明'</span></span><br></pre></td></tr></table></figure><p><strong>查看版本库的状态</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure><h3 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h3><p><strong>创建分支</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch 分支名称</span><br></pre></td></tr></table></figure><p><strong>切换分支</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout 分支名称</span><br></pre></td></tr></table></figure><p><strong>创建并切换分支</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b 分支名称</span><br></pre></td></tr></table></figure><p><strong>删除分支</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -d 分支名称</span><br></pre></td></tr></table></figure><p><strong>查看所有分支</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch</span><br></pre></td></tr></table></figure><p><strong>合并分支</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge 准备与当前分支合并的分支名称</span><br></pre></td></tr></table></figure><p><strong>若merge出现冲突，解决办法请参考</strong><a href="https://www.liaoxuefeng.com/wiki/896043488029600/900004111093344" target="_blank" rel="noopener"><strong>这里</strong></a></p><p><strong>stash功能</strong><br>当在当前分支编辑内容时，没有add和commit就切换到其它分支，发现其它分支中也会出现相应更改，stash功能可以解决这个问题。如果出现这种情况，正在当前分支编辑，需要临时去其他分支处理一些事情，但是当前分支又不能add和commit，这时就需要stash功能，可以它就像一个icebox，能当前工作冻结。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash</span><br></pre></td></tr></table></figure><p>查看冻结列表：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash list</span><br></pre></td></tr></table></figure><p>想解冻2种方法：<br>第一种：解冻的同时把stash记录也删了，也就是在list中看不到了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash pop</span><br></pre></td></tr></table></figure><p>第二种：解冻不删list中记录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash apply</span><br></pre></td></tr></table></figure><p>想删记录：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash drop</span><br></pre></td></tr></table></figure><h2 id="2-时光穿梭"><a href="#2-时光穿梭" class="headerlink" title="2.时光穿梭"></a>2.时光穿梭</h2><h3 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h3><p>当不断对文件进行修改，然后不断提交修改到版本库里，难免会出现失误，把文件改乱或出现其他错误，就需要回到上一次或者之前任一次提交的状态。<br>首先<strong>查看提交历史记录</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span></span><br></pre></td></tr></table></figure><p>返回结果中commit 后面的十六进制数即为该次提交的commit id。<br>想返回<strong>结果简化</strong>一点：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> --pretty=oneline</span><br></pre></td></tr></table></figure><p><strong>想看到merge情况</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> --graph</span><br></pre></td></tr></table></figure><p>同样有<strong>简化板</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log --graph --pretty=oneline</span><br></pre></td></tr></table></figure><p><strong>回退到上一版本</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard head^</span><br></pre></td></tr></table></figure><p>同理，回退到上上版本就是head^^，以此类推，当然往上100个版本写100个^比较容易数不过来，所以写成head~100.<br>也可以<strong>根据commit id回到该版本</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard [commit id前几位]</span><br></pre></td></tr></table></figure><p>如果有20个版本，回退到第10个版本，但是后悔了，想回退到第15个版本，这是再去看提交历史记录，第11到20个版本的记录已经不在了，找不到commit id怎么办，可以用以下命令查到commit id前几位：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reflog</span><br></pre></td></tr></table></figure><h3 id="撤销修改或删除"><a href="#撤销修改或删除" class="headerlink" title="撤销修改或删除"></a>撤销修改或删除</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -- file_name</span><br></pre></td></tr></table></figure><p>file_name即为想撤销修改或删除的文件名<br>使用以上命令分三种情况：<br>1.工作区文件自修改后还没有被放到暂存区，现在撤销修改就回到版本库中分支一样的状态；<br>2.工作区文件自修改后已经添加到暂存区后，又作了修改或者删除，现在撤销修改或删除就回到和暂存区一样的状态；<br>3.工作区文件自修改后已经commit到分支，又作了修改或者删除，现在撤销或修删除改就回到和分支一样的状态。</p><p><strong>撤销暂存区的修改或删除：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset HEAD file_name</span><br></pre></td></tr></table></figure><p>如果commit到了分支，直接版本回退吧</p><h2 id="3-远程仓库"><a href="#3-远程仓库" class="headerlink" title="3.远程仓库"></a>3.远程仓库</h2><p><strong>从远程仓库克隆：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> 地址</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> -b 分支名称 地址</span><br></pre></td></tr></table></figure><p><strong>将本地分支推送到远程库</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin 当前分支名称</span><br></pre></td></tr></table></figure><p><strong>将远程库拉取到本地分支</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull origin 要拉取到分支名称</span><br></pre></td></tr></table></figure><h2 id="4-标签管理"><a href="#4-标签管理" class="headerlink" title="4.标签管理"></a>4.标签管理</h2><p>给当前分支<strong>打标签</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag 标签内容</span><br></pre></td></tr></table></figure><p><strong>指定commit id打标签</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag 标签内容 commit id前几位</span><br></pre></td></tr></table></figure><p><strong>查看标签</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag</span><br></pre></td></tr></table></figure><p><strong>查看标签详细情况</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag 标签内容</span><br></pre></td></tr></table></figure><p><strong>删除标签</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag -d 标签内容</span><br></pre></td></tr></table></figure><p><strong>推送一个本地标签</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin 标签内容</span><br></pre></td></tr></table></figure><p><strong>推送全部未推送过的本地标签</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin --tags</span><br></pre></td></tr></table></figure><p><strong>删除一个远程标签</strong><br>现在本地删除：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag -d 标签内容</span><br></pre></td></tr></table></figure><p>再执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin :refs/tags/标签内容</span><br></pre></td></tr></table></figure><p>好了，就这么多，如有错误望指出。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Git —— 大名鼎鼎的分布式版本控制系统，据说是Linux系统之父Linus花两周时间写出来的，怎一个牛字了得。&lt;br&gt;写过代码的人大都知道它，以写代码为生的人大都离不开它。&lt;br&gt;官方文档实在太难用，这里参考大佬&lt;a href=&quot;https://www.liaoxuefeng.com/wiki/896043488029600&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;strong&gt;廖雪峰的教程&lt;/strong&gt;&lt;/a&gt;，把常用命令总结写两下来，以供自己和一起搬砖的朋友备查。
    
    </summary>
    
    
      <category term="Code Tool" scheme="https://jkknotes.com/categories/Code-Tool/"/>
    
      <category term="命令速查" scheme="https://jkknotes.com/categories/Code-Tool/%E5%91%BD%E4%BB%A4%E9%80%9F%E6%9F%A5/"/>
    
    
      <category term="Git" scheme="https://jkknotes.com/tags/Git/"/>
    
      <category term="Tool" scheme="https://jkknotes.com/tags/Tool/"/>
    
  </entry>
  
  <entry>
    <title>kaggle实战——What Causes Heart Disease?</title>
    <link href="https://jkknotes.com/kaggle%E5%AE%9E%E6%88%98%E2%80%94%E2%80%94What%20Causes%20Heart%20Disease_/"/>
    <id>https://jkknotes.com/kaggle实战——What Causes Heart Disease_/</id>
    <published>2019-04-07T04:29:29.000Z</published>
    <updated>2019-11-03T13:47:42.285Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote><p><strong>记得有一次去面试，那个公司的HR聊天说，她感觉程序员面试那是面真功夫，会就会，不会装也没用。从这里想开来，还真是，码农学再多理论，终究是要去码砖的。我呢就是原来机器学习和深度学习的理论学的多，实践反而少，所以感觉有时候做事情就慢了些。<a id="more"></a>现在趁着还有些闲工夫，就找一些项目做做，由简单到复杂，慢慢来吧。</strong></p></blockquote><p><strong>本文同步发在我的 <a href="https://blog.csdn.net/iizhuzhu/article/details/89067386" target="_blank" rel="noopener">CSDN Blog</a>，2019.4.5 刚搞成功，接下来CSDN和 <a href="http://jkknotes.com/">KK’s Notes</a> 同时更新，各位看官大佬多多指教。</strong></p><h2 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1. Introduction"></a>1. Introduction</h2><p>这个项目来自于<a href="https://www.kaggle.com/tentotheminus9/what-causes-heart-disease-explaining-the-model/notebook" target="_blank" rel="noopener">kaggle</a>。项目主要是利用患者的个人信息和检查数据，利用机器学习方法来诊断该患者收否患疾病，并且尝试对识别结果作出解释。这个项目虽然简单但将机器学习的全流程和常用预处理和分析方法都涉及到了，我做完一遍还是有很多收获。以下操作皆在 <strong>Jubyter notebook</strong> 下以 <strong>Python</strong> 进行的。</p><p>主要使用的技术：</p><ul><li>Random Forest</li><li>Feature Importance Analysis: <strong>Permutation importance</strong></li><li>Feature Importance Analysis: <strong>Partial Dependence Plots</strong></li></ul><h2 id="2-Data"><a href="#2-Data" class="headerlink" title="2. Data"></a>2. Data</h2><p>Data from：<a href="https://www.kaggle.com/ronitf/heart-disease-uci/downloads/heart.csv/" target="_blank" rel="noopener">https://www.kaggle.com/ronitf/heart-disease-uci/downloads/heart.csv/</a><br>About Data：下载好数据之后直接打开看一看。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">data = pd.read_csv(<span class="string">'data/heart.csv'</span>)</span><br><span class="line">data.info()</span><br></pre></td></tr></table></figure><p>Output:<br><img src="https://gitee.com/jjkkk/cloud_img/raw/master/1904/b1.png" width="342" height="334"><br>可以看到总共有303条数据以及13个特征和1个标签，数据没有缺失项。接下看下前十个数据。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data.head(<span class="number">10</span>)</span><br></pre></td></tr></table></figure><p>Output:<br><img src="https://gitee.com/jjkkk/cloud_img/raw/master/1904/b2.png" width="621" height="308"><br>这13个特征的含义分别是：</p><blockquote><p>age: 年龄<br>sex：该人的性别（1=男性，0=女性）<br>cp：胸痛经历（值1：典型心绞痛，值2：非典型心绞痛，值3：非心绞痛，值4：无症状）<br>trestbps：该人的静息血压（入院时为mm Hg）<br>chol：人体胆固醇测量单位为mg/dl<br>fbs：该人的空腹血糖（&gt; 120mg/dl，1=true; 0= f=alse）<br>restecg：静息心电图测量（0=正常，1=有ST-T波异常，2=按Estes标准显示可能或明确的左心室肥厚）<br>thalach：达到了该人的最大心率<br>exang：运动诱发心绞痛（1=是; 0=否）<br>oldpeak：运动相对于休息引起的ST段压低（’ST’与ECG图上的位置有关）<br>slope：峰值运动ST段的斜率（值1：上升，值2：平坦，值3：下降）<br>ca：主要血管数量（0-3）<br>thal：称为地中海贫血的血液疾病（1=正常; 2=固定缺陷; 3=可逆缺陷）<br>target：心脏病（0=不，1=是）</p></blockquote><p>为了更好的理解数据，我们应该提前查一下每个特征的含义，以及医学上该特征和心脏病的关系。具体这里不再赘述。</p><h2 id="3-数据预处理"><a href="#3-数据预处理" class="headerlink" title="3. 数据预处理"></a>3. 数据预处理</h2><p>这里为了方便后续做心脏病诊断中影响因素分析即Feature Importance Analysis（还是觉得用英文更能表达意思），将部分数值型特征进行转换：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">data.loc[data.sex == <span class="number">1</span>, <span class="string">'sex'</span>] = <span class="string">'male'</span></span><br><span class="line">data.loc[data[<span class="string">'sex'</span>] == <span class="number">0</span>, <span class="string">'sex'</span>] = <span class="string">'female'</span></span><br><span class="line"></span><br><span class="line">data.loc[data[<span class="string">'cp'</span>] == <span class="number">1</span>, <span class="string">'cp'</span>] = <span class="string">'typical'</span></span><br><span class="line">data.loc[data[<span class="string">'cp'</span>] == <span class="number">2</span>, <span class="string">'cp'</span>] = <span class="string">'atypical'</span></span><br><span class="line">data.loc[data[<span class="string">'cp'</span>] == <span class="number">3</span>, <span class="string">'cp'</span>] = <span class="string">'no_pain'</span></span><br><span class="line">data.loc[data[<span class="string">'cp'</span>] == <span class="number">4</span>, <span class="string">'cp'</span>] = <span class="string">'no_feel'</span></span><br><span class="line"></span><br><span class="line">data.loc[data[<span class="string">'fbs'</span>] == <span class="number">1</span>, <span class="string">'fbs'</span>] = <span class="string">'higher than 120 mg/dl'</span></span><br><span class="line">data.loc[data[<span class="string">'fbs'</span>] == <span class="number">0</span>, <span class="string">'fbs'</span>] = <span class="string">'lower than 120 mg/dl'</span></span><br><span class="line"></span><br><span class="line">data.loc[data[<span class="string">'restecg'</span>] == <span class="number">0</span>, <span class="string">'restecg'</span>] = <span class="string">'normal'</span></span><br><span class="line">data.loc[data[<span class="string">'restecg'</span>] == <span class="number">1</span>, <span class="string">'restecg'</span>] = <span class="string">'ST-T wave abnormality'</span></span><br><span class="line">data.loc[data[<span class="string">'restecg'</span>] == <span class="number">2</span>, <span class="string">'restecg'</span>] = <span class="string">'left ventricular hypertrophy'</span></span><br><span class="line"></span><br><span class="line">data.loc[data[<span class="string">'exang'</span>] == <span class="number">1</span>, <span class="string">'exang'</span>] = <span class="string">'true'</span></span><br><span class="line">data.loc[data[<span class="string">'exang'</span>] == <span class="number">0</span>, <span class="string">'exang'</span>] = <span class="string">'false'</span></span><br><span class="line"></span><br><span class="line">data.loc[data[<span class="string">'slope'</span>] == <span class="number">1</span>, <span class="string">'slope'</span>] = <span class="string">'up'</span></span><br><span class="line">data.loc[data[<span class="string">'slope'</span>] == <span class="number">2</span>, <span class="string">'slope'</span>] = <span class="string">'flat'</span></span><br><span class="line">data.loc[data[<span class="string">'slope'</span>] == <span class="number">3</span>, <span class="string">'slope'</span>] = <span class="string">'down'</span></span><br><span class="line"></span><br><span class="line">data.loc[data[<span class="string">'thal'</span>] == <span class="number">1</span>, <span class="string">'thal'</span>] = <span class="string">'normal'</span></span><br><span class="line">data.loc[data[<span class="string">'thal'</span>] == <span class="number">2</span>, <span class="string">'thal'</span>] = <span class="string">'fixed defect'</span></span><br><span class="line">data.loc[data[<span class="string">'thal'</span>] == <span class="number">3</span>, <span class="string">'thal'</span>] = <span class="string">'reversable defect'</span></span><br></pre></td></tr></table></figure><p>检查下数据情况：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data.describe(include=[np.object])</span><br></pre></td></tr></table></figure><p>Output:<br><img src="https://gitee.com/jjkkk/cloud_img/raw/master/1904/b3.png" width="560" height="147"><br>可以看到特征thal有4个值，而我们在转换时只转换了3个。实际上thal存在2个缺失值用0补齐的。为了防止数据类型错误，这里做一下类型转换。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data[<span class="string">'thal'</span>] = data[<span class="string">'thal'</span>].astype(<span class="string">'object'</span>)</span><br></pre></td></tr></table></figure><p>再看下数据：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data.head()</span><br></pre></td></tr></table></figure><p>Output:<br><img src="https://gitee.com/jjkkk/cloud_img/raw/master/1904/b4.png" width="889" height="174"><br>模型的训练肯定需要数值型特征。这里对特征进行Onehot编码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">data = pd.get_dummies(data, drop_first=<span class="literal">True</span>)</span><br><span class="line">data.head()</span><br></pre></td></tr></table></figure><p>Output：<br><img src="https://gitee.com/jjkkk/cloud_img/raw/master/1904/b5.png" width="1011" height="186"><br>（由于我还不知道在用markdown编辑时怎么显示运行结果，这里用的是截图，只能截取一部分，还有特征没有截取出来）<br>数据预处理部分就到此为止，接下来上模型。</p><h2 id="4-Random-Forest"><a href="#4-Random-Forest" class="headerlink" title="4. Random Forest"></a>4. Random Forest</h2><p>对于 Random Forest 的原理这里就不介绍了，网上介绍的文章也很多。废话不多说，直接import package.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"><span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> RandomForestClassifier</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br></pre></td></tr></table></figure><p>将数据分成 train_data 和 test_data 2个集合，二者比例为8:2。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">train_x, test_x, train_y, test_y = train_test_split(data.drop(columns=<span class="string">'target'</span>),</span><br><span class="line">                                                    data[<span class="string">'target'</span>],</span><br><span class="line">                                                    test_size=<span class="number">0.2</span>,</span><br><span class="line">                                                    random_state=<span class="number">10</span>)</span><br></pre></td></tr></table></figure><p>简单的画个图调个参。这里 Random Forest 主要的参数有基学习器决策树的最大深度（这里依据经验选5）、基学习器个数 n_estimators。这里基学习器选用CART。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">train_score = []</span><br><span class="line">test_score = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">100</span>):</span><br><span class="line">    model = RandomForestClassifier(max_depth=<span class="number">5</span>,</span><br><span class="line">                                   n_estimators=n，</span><br><span class="line">                                   criterion=<span class="string">'gini'</span>)</span><br><span class="line">    model.fit(train_x, train_y)</span><br><span class="line">    train_score.append(model.score(train_x, train_y))</span><br><span class="line">    test_score.append(model.score(test_x, test_y))</span><br></pre></td></tr></table></figure><p>训练完，把train和test上的accuracy随基学习器个数的变化画成图。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">x_axis = [i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">100</span>)]</span><br><span class="line"></span><br><span class="line">fig, ax = plt.subplots()</span><br><span class="line">ax.plot(x_axis, train_score[:<span class="number">99</span>])</span><br><span class="line">ax.plot(x_axis, test_score[:<span class="number">99</span>], c=<span class="string">"r"</span>)</span><br><span class="line">plt.xlim([<span class="number">0</span>, <span class="number">100</span>])</span><br><span class="line">plt.ylim([<span class="number">0.0</span>, <span class="number">1.0</span>])</span><br><span class="line">plt.rcParams[<span class="string">'font.size'</span>] = <span class="number">12</span></span><br><span class="line">plt.xlabel(<span class="string">'n_estimators'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'accuracy'</span>)</span><br><span class="line">plt.grid(<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><p>Output：<br><img src="https://gitee.com/jjkkk/cloud_img/raw/master/1904/b6.png" alt><br>可以看到大概是n_estimators=14的时候效果最好，train和test上的accuracy分别是0.9463，0.8361。看上去没有那么差。</p><h2 id="5-模型评估"><a href="#5-模型评估" class="headerlink" title="5. 模型评估"></a>5. 模型评估</h2><p>训练完模型，用<a href="https://en.wikipedia.org/wiki/Receiver_operating_characteristic" target="_blank" rel="noopener">ROC曲线</a>来评估下模型的效果。ROC曲线事宜FPR和TPR分别为横纵轴作出的曲线，其和坐标轴围成的面积越大，说明模型效果越好。具体评判标准见下文。说一下几个概念：</p><blockquote><ul><li>TPR: 真正例率，表示所有真正为正例的样本被正确预测出来的比例，等同于Recall</li><li>FNR: 假负例率，FNR = 1 - TPR</li><li>FPR: 假正例率，表示所有负例中被预测为正例的比例。</li><li>TNR: 真负例率，TNR = 1 - FPR</li></ul></blockquote><p>好吧，我也快晕了。<br>接下来计算一下正例和负例的recall</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> confusion_matrix</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> auc, roc_curve</span><br><span class="line"></span><br><span class="line"><span class="comment"># 混淆矩阵</span></span><br><span class="line">confusion_m = confusion_matrix(test_y, pred_y) </span><br><span class="line"><span class="keyword">print</span> confusion_m</span><br></pre></td></tr></table></figure><p>Output:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[[29  6]</span><br><span class="line"> [ 4 22]]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">total = confusion_m.sum()</span><br><span class="line">tpr = float(confusion_m[<span class="number">0</span>][<span class="number">0</span>]) / (confusion_m[<span class="number">0</span>][<span class="number">0</span>] + confusion_m[<span class="number">1</span>][<span class="number">0</span>])</span><br><span class="line">tnr = float(confusion_m[<span class="number">1</span>][<span class="number">1</span>]) / (confusion_m[<span class="number">1</span>][<span class="number">1</span>] + confusion_m[<span class="number">0</span>][<span class="number">1</span>])</span><br><span class="line"><span class="keyword">print</span> tpr, tnr</span><br></pre></td></tr></table></figure><p>Output:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0.878787878788 0.785714285714</span><br></pre></td></tr></table></figure><p>Just so so!!</p><p>画ROC曲线图：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">pred_y = model.predict(test_x)  <span class="comment"># 预测结果</span></span><br><span class="line">pred_prob_y = model.predict_proba(test_x)[:, <span class="number">1</span>]  <span class="comment"># 为正例的概率</span></span><br><span class="line">fpr_list, tpr_list, throsholds = roc_curve(test_y, pred_prob_y)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 画图</span></span><br><span class="line">fig, ax = plt.subplots()</span><br><span class="line">ax.plot(fpr_list, tpr_list)</span><br><span class="line">ax.plot([<span class="number">0</span>, <span class="number">1</span>], [<span class="number">0</span>, <span class="number">1</span>], transform=ax.transAxes, ls=<span class="string">"--"</span>, c=<span class="string">"r"</span>)</span><br><span class="line">plt.xlim([<span class="number">0.0</span>, <span class="number">1.0</span>])</span><br><span class="line">plt.ylim([<span class="number">0.0</span>, <span class="number">1.0</span>])</span><br><span class="line">plt.rcParams[<span class="string">'font.size'</span>] = <span class="number">12</span></span><br><span class="line">plt.title(<span class="string">'roc curve'</span>)</span><br><span class="line">plt.xlabel(<span class="string">'fpr'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'tpr'</span>)</span><br><span class="line">plt.grid(<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><p>Output:<br><img src="https://gitee.com/jjkkk/cloud_img/raw/master/1904/ROC.png" alt><br>前文说了，ROC曲线和坐标轴围成的面积越大，说明模型效果越好。这个面积就叫 AUC .根据AUC的值，可参考下面的规则评估模型：</p><blockquote><ul><li>0.90 - 1.00 = excellent</li><li>0.80 - 0.90 = good</li><li>0.70 - 0.80 = fair</li><li>0.60 - 0.70 = poor</li><li>0.50 - 0.60 = fail</li></ul></blockquote><p>看看我们训练模型的AUC</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">auc(fpr_list, tpr_list)</span><br></pre></td></tr></table></figure><p>Output:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0.9032967032967033</span><br></pre></td></tr></table></figure><p>OK， working well！<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly90aW1nc2EuYmFpZHUuY29tL3RpbWc_aW1hZ2UmcXVhbGl0eT04MCZzaXplPWI5OTk5XzEwMDAwJnNlYz0xNTU0NjM2NjI5MjM4JmRpPWI3N2Q3MWU2MzVmOGVkMmU3ZmE0MGM4NDdhYzFiODkzJmltZ3R5cGU9MCZzcmM9aHR0cDovL2Itc3NsLmR1aXRhbmcuY29tL3VwbG9hZHMvaXRlbS8yMDE3MDMvMjkvMjAxNzAzMjkxNjE3MjhfZmRTTUYudGh1bWIuMjI0XzAuZ2lm" alt=""></p><h2 id="6-Feature-Importance-Analysis"><a href="#6-Feature-Importance-Analysis" class="headerlink" title="6. Feature Importance Analysis"></a>6. Feature Importance Analysis</h2><p>训练完模型，我们希望能从模型里得到点什么， 比如说哪些特征对模型结果贡献率比较大，是不是意味着这些影响因素在实际心脏病诊断中也是很重要对参考，或者说还能发现一些现有医学没有发现的发现。所有接下来我们做的是一件很有意思的事。</p><h5 id="6-1-决策树可视化"><a href="#6-1-决策树可视化" class="headerlink" title="6.1 决策树可视化"></a>6.1 决策树可视化</h5><p>如果我没记错的话， 根据决策树的原理，越先分裂的特征越重要。那么下面对决策树进行可视化，看看它到底做了什么。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.tree <span class="keyword">import</span> export_graphviz</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出 feature_name</span></span><br><span class="line">estimator = model.estimators_[<span class="number">1</span>]</span><br><span class="line">features = [i <span class="keyword">for</span> i <span class="keyword">in</span> train_x.columns]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 0 —&gt; no disease，1 —&gt; disease</span></span><br><span class="line">train_y_str = train_y.astype(<span class="string">'str'</span>)</span><br><span class="line">train_y_str[train_y_str == <span class="string">'0'</span>] = <span class="string">'no disease'</span></span><br><span class="line">train_y_str[train_y_str == <span class="string">'1'</span>] = <span class="string">'disease'</span></span><br><span class="line">train_y_str = train_y_str.values</span><br></pre></td></tr></table></figure><p>sklearn 真是个好东西，你能想到对功能他都有。下面用 sklearn 的 export_graphviz 对决策树进行可视化。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">export_graphviz(estimator, out_file=<span class="string">'tree.dot'</span>, </span><br><span class="line">                feature_names = features,</span><br><span class="line">                class_names = train_y_str,</span><br><span class="line">                rounded = <span class="literal">True</span>, proportion = <span class="literal">True</span>, </span><br><span class="line">                label=<span class="string">'root'</span>,</span><br><span class="line">                precision = <span class="number">2</span>, filled = <span class="literal">True</span>)</span><br></pre></td></tr></table></figure><p>生成对这个 tree.dot 文件还不能直接看，网上查了一下，把它输出来看看。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pydotplus</span><br><span class="line"><span class="keyword">from</span> IPython.display <span class="keyword">import</span> Image</span><br><span class="line">img = pydotplus.graph_from_dot_file(<span class="string">'tree.dot'</span>)</span><br><span class="line"><span class="comment">#img.write_pdf('tree.pdf') #输出成PDF</span></span><br><span class="line">Image(img.create_png())</span><br></pre></td></tr></table></figure><p>Output：<br><img src="https://gitee.com/jjkkk/cloud_img/raw/master/1904/tree.png" alt><br>实际上这张图就解释来决策树的生成过程。一般我们认为最先分裂的特征越重要，但是从这张图我们并不能很直观的看出特征的重要性。</p><h5 id="6-2-Permutation-importance"><a href="#6-2-Permutation-importance" class="headerlink" title="6.2 Permutation importance"></a>6.2 Permutation importance</h5><p>我们换一个工具—<a href="https://www.kaggle.com/dansbecker/permutation-importance" target="_blank" rel="noopener">Permutation importance</a>. 其原理是依次打乱test_data中其中一个特征数值的顺序，其实就是做shuffle，然后观察模型的效果，下降的多的说明这个特征对模型比较重要。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> eli5</span><br><span class="line"><span class="keyword">from</span> eli5.sklearn <span class="keyword">import</span> PermutationImportance</span><br><span class="line"></span><br><span class="line">perm = PermutationImportance(model, random_state=<span class="number">20</span>).fit(test_x, test_y)</span><br><span class="line">eli5.show_weights(perm, feature_names=test_x.columns.tolist())</span><br></pre></td></tr></table></figure><p>Output：<br><img src="https://gitee.com/jjkkk/cloud_img/raw/master/1904/feature_w.png" width="323" height="290"><br>一目了然，一切尽在不言中。还是说俩句吧，绿色越深表示正相关越强，红色越深表示负相关越强。<br>实际上我发现改变 PermutationImportance 的参数 random_state 的值结果变化挺大的，不过还是有几个特征位次变化不大，结果还是具有参考意义。</p><h5 id="6-3-Partial-Dependence-Plots"><a href="#6-3-Partial-Dependence-Plots" class="headerlink" title="6.3 Partial Dependence Plots"></a>6.3 Partial Dependence Plots</h5><p>我们试试另一个工具—<a href="https://www.kaggle.com/dansbecker/partial-plots" target="_blank" rel="noopener">Partial Dependence Plots</a>. 其原理和 Permutation importance 有点类似，当它判断一个特征对模型的影响时，对于所有样本，将该特征依次取该特征的所有取值，观察模型结果的变化。先画图，再根据图解释一下。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pdpbox <span class="keyword">import</span> pdp, info_plots</span><br><span class="line"></span><br><span class="line">total_features = train_x.columns.values.tolist()</span><br><span class="line">feature_name = <span class="string">'oldpeak'</span></span><br><span class="line">pdp_dist = pdp.pdp_isolate(model=model, dataset=test_x, model_features=total_features, feature=feature_name)</span><br><span class="line"></span><br><span class="line">pdp.pdp_plot(pdp_dist, feature_name)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>Output：<br><img src="https://gitee.com/jjkkk/cloud_img/raw/master/1904/b7.png" width="670" height="425"><br>上图的纵坐标是模型相对于base model 的变化，横坐标是该特征的所有取值，实线表示相对于base model 的变化的平均值，蓝色阴影表示置信度。oldpeak表示运动相对于休息引起的ST段压低，可以看到其取值越大，患心脏病的可能性越低。不知道这个结果可不可信，我觉得需要医学知识作支撑。</p><p>又试了几个特征：</p><p><strong>Sex：</strong><br><img src="https://gitee.com/jjkkk/cloud_img/raw/master/1904/b8.png" width="670" height="425"><br>上图说明男性比女性患心脏病的概率要低些，网上查了一下，还真是这样。</p><p><strong>Age：</strong><br><img src="https://gitee.com/jjkkk/cloud_img/raw/master/1904/b9.png" width="670" height="425"><br>上图表示60岁以上老人心脏病高发，这个和现有理论相符。</p><p>接下来看一下 <strong>2D Partial Dependence Plots</strong>.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">inter = pdp.pdp_interact(model=model, </span><br><span class="line"> dataset=test_x, </span><br><span class="line"> model_features=total_features, </span><br><span class="line"> features=[<span class="string">'oldpeak'</span>, <span class="string">'age'</span>])</span><br><span class="line"></span><br><span class="line">pdp.pdp_interact_plot(pdp_interact_out=inter, </span><br><span class="line">  feature_names=[<span class="string">'oldpeak'</span>, <span class="string">'age'</span>], </span><br><span class="line">  plot_type=<span class="string">'contour'</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>Output：<br><img src="https://gitee.com/jjkkk/cloud_img/raw/master/1904/b10.png" alt><br>这个图一开始没看懂，后来仔细看了<a href="https://www.kaggle.com/dansbecker/partial-plots" target="_blank" rel="noopener">Partial Dependence Plots</a> 的说明文档才搞明白。图中颜色从浅到深表示患心脏病概率降低，以最深的那个紫色为例，oldpeak &gt; 3.0 &amp;&amp; 45 &lt; age &lt; 65 时，患病概率最低，图中黄色部分表示，oldpeak &lt; 0.25 &amp;&amp;  ( age &lt; 45 || age &gt; 65 ) 时，患病概率最高。</p><h2 id="7-后记"><a href="#7-后记" class="headerlink" title="7. 后记"></a>7. 后记</h2><p>实际上本项目的数据是非常小的，其结果的可靠性也是值得怀疑的。但是通过这个项目，去经历机器学习项目的完整过程，却能学到很多东西。重要的是过程，更重要的是举一反三。该项目还引入了2个很有趣的Feature Importance Analysis的方法，对于我来说是新知识，也算是学到了。</p><p>这一篇到这里结束了，期待下一篇。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;记得有一次去面试，那个公司的HR聊天说，她感觉程序员面试那是面真功夫，会就会，不会装也没用。从这里想开来，还真是，码农学再多理论，终究是要去码砖的。我呢就是原来机器学习和深度学习的理论学的多，实践反而少，所以感觉有时候做事情就慢了些。
    
    </summary>
    
    
      <category term="Machine Learning" scheme="https://jkknotes.com/categories/Machine-Learning/"/>
    
      <category term="项目实战" scheme="https://jkknotes.com/categories/Machine-Learning/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/"/>
    
    
      <category term="AI医疗" scheme="https://jkknotes.com/tags/AI%E5%8C%BB%E7%96%97/"/>
    
      <category term="Machine Learning" scheme="https://jkknotes.com/tags/Machine-Learning/"/>
    
      <category term="Random Forest" scheme="https://jkknotes.com/tags/Random-Forest/"/>
    
      <category term="Feature Engineering" scheme="https://jkknotes.com/tags/Feature-Engineering/"/>
    
  </entry>
  
</feed>
